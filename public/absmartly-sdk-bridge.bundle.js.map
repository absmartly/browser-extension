{
  "version": 3,
  "sources": ["../src/sdk-bridge/index.ts", "../src/sdk-bridge/utils/logger.ts", "../src/sdk-bridge/sdk/sdk-detector.ts", "../src/sdk-bridge/sdk/plugin-detector.ts", "../src/sdk-bridge/sdk/sdk-interceptor.ts", "../src/sdk-bridge/utils/html-sanitizer.ts", "../src/sdk-bridge/experiment/code-injector.ts", "../src/sdk-bridge/experiment/override-manager.ts", "../src/sdk-bridge/core/orchestrator.ts"],
  "sourcesContent": ["/**\n * ABsmartly SDK Bridge - Main Entry Point\n *\n * This module bridges the ABsmartly browser extension with the ABsmartly SDK\n * running on the page. It handles SDK detection, plugin initialization,\n * DOM changes, and message passing.\n *\n * @module ABSmartlySDKBridge\n * @version 1.1.0\n */\n\nimport { Orchestrator } from './core/orchestrator'\n\n// Version\nexport const SDK_BRIDGE_VERSION = '1.1.0'\n\n// Create orchestrator instance\nconst orchestrator = new Orchestrator()\n\n// Setup message listener for extension communication\norchestrator.setupMessageListener()\n\n// Expose APIs for extension to call\norchestrator.exposeVariantAssignments()\norchestrator.exposeContextPath()\n\n// Start the initialization process\norchestrator.start()\n\n// Log that we're loaded\nconsole.log('[SDK Bridge] Module loaded - version', SDK_BRIDGE_VERSION)\n", "/**\n * Debug Logger Utility\n *\n * Centralized logging for SDK Bridge with debug mode control\n *\n * @module Logger\n */\n\nexport class Logger {\n  private static DEBUG = true\n\n  /**\n   * Log an info message\n   */\n  static log(...args: any[]): void {\n    if (this.DEBUG) {\n      console.log('[ABsmartly Extension]', ...args)\n    }\n  }\n\n  /**\n   * Log an error message\n   */\n  static error(...args: any[]): void {\n    if (this.DEBUG) {\n      console.error('[ABsmartly Extension]', ...args)\n    }\n  }\n\n  /**\n   * Log a warning message\n   */\n  static warn(...args: any[]): void {\n    if (this.DEBUG) {\n      console.warn('[ABsmartly Extension]', ...args)\n    }\n  }\n\n  /**\n   * Enable or disable debug logging\n   */\n  static setDebug(enabled: boolean): void {\n    this.DEBUG = enabled\n  }\n\n  /**\n   * Check if debug mode is enabled\n   */\n  static isDebugEnabled(): boolean {\n    return this.DEBUG\n  }\n}\n", "/**\n * SDK Detector\n *\n * Detects ABsmartly SDK and context on window object\n *\n * @module SDKDetector\n */\n\nimport { Logger } from '../utils/logger'\n\nexport interface SDKDetectionResult {\n  sdk: any | null\n  context: any | null\n  contextPath: string | null\n}\n\nexport class SDKDetector {\n  private cachedContext: any = null\n  private contextPropertyPath: string | null = null\n\n  /**\n   * Detect ABsmartly SDK on the window object\n   */\n  detectSDK(): SDKDetectionResult {\n    // Return cached context if available\n    if (this.cachedContext) {\n      return {\n        sdk: null,\n        context: this.cachedContext,\n        contextPath: this.contextPropertyPath\n      }\n    }\n\n    // Check for SDK instances (have createContext method)\n    let sdk = null\n    const sdkLocations = [\n      (window as any).sdk,\n      (window as any).absmartly,\n      (window as any).ABsmartly,\n      (window as any).__absmartly\n    ]\n\n    for (const location of sdkLocations) {\n      if (location && typeof location.createContext === 'function') {\n        sdk = location\n        Logger.log('[ABsmartly Extension] SDK instance found')\n        break\n      }\n    }\n\n    // Check common context locations\n    const possibleLocations = [\n      (window as any).ABsmartlyContext,\n      (window as any).absmartly,\n      (window as any).ABsmartly,\n      (window as any).__absmartly,\n      (window as any).sdk,\n      (window as any).abSmartly,\n      (window as any).context,\n      (window as any).absmartlyContext,\n      (window as any).__context\n    ]\n\n    let context = null\n\n    // First pass: Check if any location is directly a context (has treatment method)\n    for (const location of possibleLocations) {\n      if (location && typeof location.treatment === 'function') {\n        context = location\n        break\n      }\n    }\n\n    // Second pass: Check if any location has a context property with treatment method\n    if (!context) {\n      for (const location of possibleLocations) {\n        if (location && location.context && typeof location.context.treatment === 'function') {\n          context = location.context\n          break\n        }\n      }\n    }\n\n    // Third pass: Check for contexts array\n    if (!context) {\n      for (const location of possibleLocations) {\n        if (location && location.contexts && Array.isArray(location.contexts) && location.contexts.length > 0) {\n          // Check each context in the array for treatment method\n          for (const ctx of location.contexts) {\n            if (ctx && typeof ctx.treatment === 'function') {\n              context = ctx\n              break\n            }\n          }\n          if (context) break\n        }\n      }\n    }\n\n    // Cache the context and its location for future use\n    if (context && !this.cachedContext) {\n      this.cachedContext = context\n\n      // Store where we found it\n      if ((window as any).ABsmartlyContext === context) {\n        this.contextPropertyPath = 'ABsmartlyContext'\n      } else if ((window as any).absmartly === context) {\n        this.contextPropertyPath = 'absmartly'\n      } else if ((window as any).sdk && (window as any).sdk.context === context) {\n        this.contextPropertyPath = 'sdk.context'\n      } else {\n        this.contextPropertyPath = 'unknown'\n      }\n\n      Logger.log('[ABsmartly Extension] \u2705 Context found and cached at:', this.contextPropertyPath)\n      Logger.log('[ABsmartly Extension] \uD83D\uDCCA Context details:', {\n        hasTreatment: !!context.treatment,\n        hasPeek: !!context.peek,\n        hasData: !!context.data,\n        hasEventLogger: !!context.eventLogger,\n        has_eventLogger: context._eventLogger !== undefined,\n        contextType: typeof context\n      })\n    } else if (!context) {\n      Logger.warn('[ABsmartly Extension] \u26A0\uFE0F No context found after detection')\n    }\n\n    return { sdk, context, contextPath: this.contextPropertyPath }\n  }\n\n  /**\n   * Get cached context\n   */\n  getCachedContext(): any | null {\n    return this.cachedContext\n  }\n\n  /**\n   * Get context property path\n   */\n  getContextPath(): string | null {\n    return this.contextPropertyPath\n  }\n\n  /**\n   * Clear cached context\n   */\n  clearCache(): void {\n    this.cachedContext = null\n    this.contextPropertyPath = null\n  }\n}\n", "/**\n * Plugin Detector\n *\n * Detects if ABsmartly DOM Changes Plugin is already loaded\n *\n * @module PluginDetector\n */\n\nimport { Logger } from '../utils/logger'\n\nexport class PluginDetector {\n  /**\n   * Checks if the DOM Changes Plugin is already loaded on the page\n   */\n  detectPlugin(context?: any): any | string | null {\n    // Check if plugin is registered with the context (primary detection method)\n    if (context && context.__domPlugin && context.__domPlugin.initialized) {\n      Logger.log('[ABsmartly Extension] Plugin detected via context.__domPlugin registration:', {\n        version: context.__domPlugin.version,\n        capabilities: context.__domPlugin.capabilities,\n        timestamp: context.__domPlugin.timestamp\n      })\n      // Plugin is properly registered with context\n      return context.__domPlugin.instance\n    }\n\n    // Check if site has its own plugin instance (they might have stored it somewhere)\n    if ((window as any).__absmartlyPlugin) {\n      Logger.log('[ABsmartly Extension] Site plugin instance found at window.__absmartlyPlugin')\n      return (window as any).__absmartlyPlugin\n    }\n\n    if ((window as any).__absmartlyDOMChangesPlugin) {\n      Logger.log('[ABsmartly Extension] Site plugin instance found at window.__absmartlyDOMChangesPlugin')\n      return (window as any).__absmartlyDOMChangesPlugin\n    }\n\n    // Check for plugin data attributes in the DOM (indicates plugin is active)\n    const pluginElements = document.querySelectorAll(\n      '[data-absmartly-modified], [data-absmartly-created], [data-absmartly-injected]'\n    )\n    if (pluginElements.length > 0) {\n      Logger.log(\n        '[ABsmartly Extension] DOM Changes Plugin artifacts found in DOM - plugin is active but instance not accessible'\n      )\n      // Plugin is active but we can't access the instance\n      return 'active-but-inaccessible'\n    }\n\n    return null\n  }\n\n  /**\n   * Check if plugin is accessible (not just active but inaccessible)\n   */\n  isPluginAccessible(detectionResult: any): boolean {\n    return detectionResult !== null && detectionResult !== 'active-but-inaccessible'\n  }\n\n  /**\n   * Check if plugin is active (either accessible or detected via DOM artifacts)\n   */\n  isPluginActive(detectionResult: any): boolean {\n    return detectionResult !== null\n  }\n}\n", "/**\n * SDK Interceptor\n *\n * Intercepts ABsmartly SDK methods to forward events to extension\n *\n * @module SDKInterceptor\n */\n\nimport { Logger } from '../utils/logger'\n\nexport interface InterceptorCallbacks {\n  onSDKEvent?: (eventName: string, data: any) => void\n}\n\nexport class SDKInterceptor {\n  private callbacks: InterceptorCallbacks\n\n  constructor(callbacks: InterceptorCallbacks = {}) {\n    this.callbacks = callbacks\n  }\n\n  /**\n   * Intercept eventLogger calls and forward to callback\n   */\n  interceptEventLogger(context: any): void {\n    Logger.log('[ABsmartly Extension] \uD83C\uDFAF interceptEventLogger called', {\n      hasContext: !!context,\n      alreadyIntercepted: context?.__eventLoggerIntercepted,\n      hasEventLogger: !!context?.eventLogger,\n      has_eventLogger: context?._eventLogger !== undefined,\n      contextKeys: context ? Object.keys(context).filter((k) => k.includes('event') || k.includes('logger')) : [],\n      allContextMethods: context ? Object.keys(context).filter((k) => typeof context[k] === 'function') : [],\n      hasTreatment: context && typeof context.treatment === 'function',\n      hasReady: context && typeof context.ready === 'function',\n      hasPeek: context && typeof context.peek === 'function'\n    })\n\n    if (!context || context.__eventLoggerIntercepted) {\n      Logger.log('[ABsmartly Extension] \u26A0\uFE0F Skipping interception - no context or already intercepted')\n      return\n    }\n\n    const originalEventLogger = context.eventLogger ? context.eventLogger() : null\n    Logger.log('[ABsmartly Extension] \uD83D\uDCDD Original eventLogger:', {\n      hasMethod: !!context.eventLogger,\n      originalEventLogger: !!originalEventLogger,\n      typeOfOriginal: typeof originalEventLogger\n    })\n\n    // Create wrapper eventLogger\n    const wrappedEventLogger = (ctx: any, eventName: string, data: any) => {\n      Logger.log('[ABsmartly Extension] \uD83D\uDD14 SDK Event:', { eventName, data })\n\n      // Call callback if registered\n      if (this.callbacks.onSDKEvent) {\n        try {\n          this.callbacks.onSDKEvent(eventName, data ? JSON.parse(JSON.stringify(data)) : null)\n        } catch (error) {\n          Logger.error('[ABsmartly Extension] Error in SDK event callback:', error)\n        }\n      }\n\n      // Call original eventLogger if it exists\n      if (originalEventLogger) {\n        originalEventLogger(ctx, eventName, data)\n      }\n    }\n\n    // Replace the eventLogger\n    if (context._eventLogger !== undefined) {\n      Logger.log('[ABsmartly Extension] \u2705 Replacing context._eventLogger')\n      context._eventLogger = wrappedEventLogger\n    } else {\n      Logger.warn('[ABsmartly Extension] \u26A0\uFE0F context._eventLogger is undefined, cannot intercept')\n    }\n\n    context.__eventLoggerIntercepted = true\n    Logger.log('[ABsmartly Extension] \u2705 EventLogger intercepted successfully')\n  }\n\n  /**\n   * Intercept SDK's createContext method to auto-intercept all new contexts\n   */\n  interceptSDKCreateContext(sdk: any): void {\n    if (!sdk || !sdk.createContext || sdk.__createContextIntercepted) {\n      return\n    }\n\n    const originalCreateContext = sdk.createContext.bind(sdk)\n    const self = this\n\n    sdk.createContext = async function (config: any) {\n      Logger.log('[ABsmartly Extension] Intercepting createContext call')\n\n      // Call original createContext\n      const context = await originalCreateContext(config)\n\n      // Intercept the eventLogger on this new context\n      self.interceptEventLogger(context)\n\n      return context\n    }\n\n    sdk.__createContextIntercepted = true\n    Logger.log('[ABsmartly Extension] SDK createContext intercepted successfully')\n  }\n\n  /**\n   * Intercept SDK constructor to intercept all SDK instances\n   */\n  interceptSDKConstructor(sdkModule: any): void {\n    if (!sdkModule || !sdkModule.SDK || sdkModule.SDK.__constructorIntercepted) {\n      return\n    }\n\n    const OriginalSDK = sdkModule.SDK\n    const self = this\n\n    // Create a proxy constructor\n    sdkModule.SDK = function (config: any) {\n      Logger.log('[ABsmartly Extension] Intercepting new SDK() call')\n\n      // Create SDK instance\n      const sdkInstance = new OriginalSDK(config)\n\n      // Intercept createContext on this SDK instance\n      if (sdkInstance && typeof sdkInstance.createContext === 'function') {\n        self.interceptSDKCreateContext(sdkInstance)\n      }\n\n      return sdkInstance\n    }\n\n    // Copy static properties\n    Object.setPrototypeOf(sdkModule.SDK, OriginalSDK)\n    Object.assign(sdkModule.SDK, OriginalSDK)\n\n    sdkModule.SDK.__constructorIntercepted = true\n    Logger.log('[ABsmartly Extension] SDK constructor intercepted successfully')\n  }\n}\n", "/**\n * HTML Sanitization Utility\n *\n * Provides XSS protection by sanitizing HTML content.\n * Removes dangerous tags, attributes, and URIs.\n *\n * @module HTMLSanitizer\n */\n\n/**\n * Sanitize HTML to prevent XSS attacks\n *\n * This function removes:\n * - Dangerous tags: script, iframe, object, embed, link, style, meta, base\n * - Event handler attributes: onerror, onload, onclick, etc.\n * - Dangerous URIs: javascript:, data:\n *\n * @param html - The HTML string to sanitize\n * @returns Sanitized HTML string safe for insertion into DOM\n *\n * @example\n * ```typescript\n * const unsafe = '<img src=x onerror=alert(1)>'\n * const safe = sanitizeHTML(unsafe) // '<img src=\"x\">'\n * ```\n */\nexport function sanitizeHTML(html: string): string {\n  if (!html) return ''\n\n  // Create a temporary element to parse the HTML\n  const temp = document.createElement('div')\n  temp.innerHTML = html\n\n  // List of dangerous tags to remove\n  const dangerousTags = [\n    'script',\n    'iframe',\n    'object',\n    'embed',\n    'link',\n    'style',\n    'meta',\n    'base'\n  ]\n\n  // List of dangerous attributes to remove\n  const dangerousAttrs = [\n    'onerror',\n    'onload',\n    'onclick',\n    'onmouseover',\n    'onfocus',\n    'onblur',\n    'onchange',\n    'onsubmit'\n  ]\n\n  // Remove dangerous tags\n  dangerousTags.forEach((tag) => {\n    const elements = temp.querySelectorAll(tag)\n    elements.forEach((el) => el.remove())\n  })\n\n  // Remove dangerous attributes from all elements\n  const allElements = temp.querySelectorAll('*')\n  allElements.forEach((el) => {\n    // Remove event handler attributes\n    dangerousAttrs.forEach((attr) => {\n      if (el.hasAttribute(attr)) {\n        el.removeAttribute(attr)\n      }\n    })\n\n    // Remove any attribute starting with 'on'\n    Array.from(el.attributes).forEach((attr) => {\n      if (attr.name.toLowerCase().startsWith('on')) {\n        el.removeAttribute(attr.name)\n      }\n    })\n\n    // Sanitize href and src attributes\n    ;['href', 'src'].forEach((attr) => {\n      if (el.hasAttribute(attr)) {\n        const value = el.getAttribute(attr)\n        // Remove javascript: and data: URIs\n        if (value && /^(javascript|data):/i.test(value)) {\n          el.removeAttribute(attr)\n        }\n      }\n    })\n  })\n\n  return temp.innerHTML\n}\n", "/**\n * Code Injector\n *\n * Handles injection of custom code from experiment variants\n *\n * @module CodeInjector\n */\n\nimport { sanitizeHTML } from '../utils/html-sanitizer'\nimport { Logger } from '../utils/logger'\n\nexport interface InjectionCode {\n  headStart?: string\n  headEnd?: string\n  bodyStart?: string\n  bodyEnd?: string\n  urlFilter?: UrlFilter\n}\n\nexport type UrlFilter =\n  | string\n  | string[]\n  | {\n      include?: string[]\n      exclude?: string[]\n      mode?: 'wildcard' | 'regex'\n      matchType?: 'path' | 'full-url' | 'domain' | 'query' | 'hash'\n    }\n\nexport type InjectionLocation = 'headStart' | 'headEnd' | 'bodyStart' | 'bodyEnd'\n\nexport class CodeInjector {\n  /**\n   * Inject custom code from experiment variants' __inject_html variables\n   */\n  injectExperimentCode(context: any): void {\n    if (!context || !context.data_) {\n      Logger.log('[ABsmartly Extension] No context data available for experiment code injection')\n      return\n    }\n\n    const data = context.data_\n\n    // Iterate through all experiments in the context\n    if (!data.experiments || !Array.isArray(data.experiments)) {\n      Logger.log('[ABsmartly Extension] No experiments found in context')\n      return\n    }\n\n    Logger.log(`[ABsmartly Extension] Checking ${data.experiments.length} experiments for injection code`)\n\n    data.experiments.forEach((experiment: any, idx: number) => {\n      try {\n        // Get the assigned variant for this experiment\n        const assignment = context.assignments_ ? context.assignments_[experiment.id] : null\n        if (assignment === null || assignment === undefined) {\n          return // Not assigned to this experiment\n        }\n\n        const variant = experiment.variants ? experiment.variants[assignment] : null\n        if (!variant || !variant.config) {\n          return\n        }\n\n        // Parse variant config\n        let variantConfig: any\n        try {\n          variantConfig =\n            typeof variant.config === 'string' ? JSON.parse(variant.config) : variant.config\n        } catch (e) {\n          Logger.warn(\n            `[ABsmartly Extension] Failed to parse variant config for experiment ${experiment.name}:`,\n            e\n          )\n          return\n        }\n\n        // Check for __inject_html variable\n        const injectHtml = variantConfig.__inject_html\n        if (!injectHtml) {\n          return // No injection code for this variant\n        }\n\n        Logger.log(\n          `[ABsmartly Extension] Found __inject_html in experiment \"${experiment.name}\", variant ${assignment}`\n        )\n\n        // Parse injection code\n        let injectionCode: InjectionCode\n        try {\n          injectionCode =\n            typeof injectHtml === 'string' ? JSON.parse(injectHtml) : injectHtml\n        } catch (e) {\n          Logger.warn(\n            `[ABsmartly Extension] Failed to parse __inject_html for experiment ${experiment.name}:`,\n            e\n          )\n          return\n        }\n\n        // Check URL filter\n        if (injectionCode.urlFilter && !this.matchesUrlFilter(injectionCode.urlFilter)) {\n          Logger.log(\n            `[ABsmartly Extension] Skipping injection for experiment \"${experiment.name}\" - URL filter not matched`\n          )\n          return\n        }\n\n        // Inject code at each location\n        const locations: InjectionLocation[] = ['headStart', 'headEnd', 'bodyStart', 'bodyEnd']\n        locations.forEach((location) => {\n          if (injectionCode[location]) {\n            Logger.log(\n              `[ABsmartly Extension] Injecting code for experiment \"${experiment.name}\" at ${location}`\n            )\n            this.executeScriptsInHTML(injectionCode[location]!, location)\n          }\n        })\n\n        Logger.log(\n          `[ABsmartly Extension] Successfully processed injection code for experiment \"${experiment.name}\"`\n        )\n      } catch (error) {\n        Logger.error(`[ABsmartly Extension] Error processing experiment ${idx}:`, error)\n      }\n    })\n  }\n\n  /**\n   * Executes script tags found in HTML content\n   * Scripts injected via innerHTML don't execute, so we need to recreate them\n   */\n  executeScriptsInHTML(html: string, location: InjectionLocation): void {\n    Logger.log(`[ABsmartly Extension] Processing scripts for ${location}`)\n\n    // Create a temporary container\n    const temp = document.createElement('div')\n    temp.innerHTML = sanitizeHTML(html)\n\n    // Find all script tags\n    const scripts = temp.querySelectorAll('script')\n\n    scripts.forEach((script, index) => {\n      Logger.log(`[ABsmartly Extension] Executing script ${index + 1} from ${location}`)\n\n      try {\n        if (script.src) {\n          // External script - create a new script element\n          const newScript = document.createElement('script')\n          newScript.src = script.src\n\n          // Copy async/defer attributes (check both property and attribute for JSDOM compatibility)\n          if (script.async || script.hasAttribute('async')) {\n            newScript.async = true\n          }\n          if (script.defer || script.hasAttribute('defer')) {\n            newScript.defer = true\n          }\n\n          newScript.setAttribute('data-absmartly-injected', location)\n\n          // Add to appropriate location\n          this.insertAtLocation(newScript, location)\n        } else {\n          // Inline script execution disabled for security (prevents code injection)\n          Logger.warn(\n            `[ABsmartly Extension] Inline script execution disabled for security from ${location}`\n          )\n        }\n      } catch (error) {\n        Logger.error(`[ABsmartly Extension] Failed to execute script from ${location}:`, error)\n      }\n    })\n  }\n\n  /**\n   * Inserts an element at the correct location based on the injection point\n   */\n  insertAtLocation(element: HTMLElement, location: InjectionLocation): void {\n    switch (location) {\n      case 'headStart':\n        if (document.head.firstChild) {\n          document.head.insertBefore(element, document.head.firstChild)\n        } else {\n          document.head.appendChild(element)\n        }\n        break\n      case 'headEnd':\n        document.head.appendChild(element)\n        break\n      case 'bodyStart':\n        if (document.body.firstChild) {\n          document.body.insertBefore(element, document.body.firstChild)\n        } else {\n          document.body.appendChild(element)\n        }\n        break\n      case 'bodyEnd':\n        document.body.appendChild(element)\n        break\n      default:\n        Logger.warn(`[ABsmartly Extension] Unknown injection location: ${location}`)\n    }\n  }\n\n  /**\n   * Helper function to check if current URL matches the filter\n   * Returns true if URL matches or if no filter is specified\n   */\n  matchesUrlFilter(urlFilter: UrlFilter): boolean {\n    if (!urlFilter) return true // No filter means apply on all pages\n\n    const currentUrl = window.location.href\n    const currentPath = window.location.pathname\n    const currentDomain = window.location.hostname\n    const currentQuery = window.location.search\n    const currentHash = window.location.hash\n\n    // Determine what to match against\n    let matchTarget: string\n    const matchType =\n      typeof urlFilter === 'object' && !Array.isArray(urlFilter)\n        ? urlFilter.matchType || 'path'\n        : 'path'\n\n    switch (matchType) {\n      case 'full-url':\n        matchTarget = currentUrl\n        break\n      case 'domain':\n        matchTarget = currentDomain\n        break\n      case 'query':\n        matchTarget = currentQuery\n        break\n      case 'hash':\n        matchTarget = currentHash\n        break\n      case 'path':\n      default:\n        matchTarget = currentPath\n    }\n\n    // Get patterns\n    let includePatterns: string[] = []\n    let excludePatterns: string[] = []\n    let isRegex = false\n\n    if (typeof urlFilter === 'string') {\n      includePatterns = [urlFilter]\n    } else if (Array.isArray(urlFilter)) {\n      includePatterns = urlFilter\n    } else {\n      includePatterns = urlFilter.include || []\n      excludePatterns = urlFilter.exclude || []\n      isRegex = urlFilter.mode === 'regex'\n    }\n\n    // Check exclude patterns first\n    if (excludePatterns.length > 0) {\n      for (const pattern of excludePatterns) {\n        if (isRegex) {\n          try {\n            const regex = new RegExp(pattern)\n            if (regex.test(matchTarget)) {\n              Logger.log(`[ABsmartly Extension] URL excluded by pattern: ${pattern}`)\n              return false\n            }\n          } catch (e) {\n            Logger.warn(`[ABsmartly Extension] Invalid regex pattern: ${pattern}`, e)\n          }\n        } else {\n          // Simple wildcard matching\n          // First escape regex special characters, then replace wildcards\n          const escapedPattern = pattern\n            .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?\n            .replace(/\\*/g, '.*') // Convert * to .*\n            .replace(/\\?/g, '.') // Convert ? to .\n          const regex = new RegExp(`^${escapedPattern}$`)\n          if (regex.test(matchTarget)) {\n            Logger.log(`[ABsmartly Extension] URL excluded by pattern: ${pattern}`)\n            return false\n          }\n        }\n      }\n    }\n\n    // Check include patterns\n    if (includePatterns.length === 0) {\n      return true // No include patterns means include all (that aren't excluded)\n    }\n\n    for (const pattern of includePatterns) {\n      if (isRegex) {\n        try {\n          const regex = new RegExp(pattern)\n          if (regex.test(matchTarget)) {\n            Logger.log(`[ABsmartly Extension] URL matched by pattern: ${pattern}`)\n            return true\n          }\n        } catch (e) {\n          Logger.warn(`[ABsmartly Extension] Invalid regex pattern: ${pattern}`, e)\n        }\n      } else {\n        // Simple wildcard matching\n        // First escape regex special characters, then replace wildcards\n        const escapedPattern = pattern\n          .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?\n          .replace(/\\*/g, '.*') // Convert * to .*\n          .replace(/\\?/g, '.') // Convert ? to .\n        const regex = new RegExp(`^${escapedPattern}$`)\n        if (regex.test(matchTarget)) {\n          Logger.log(`[ABsmartly Extension] URL matched by pattern: ${pattern}`)\n          return true\n        }\n      }\n    }\n\n    Logger.log(`[ABsmartly Extension] URL did not match any include patterns`)\n    return false\n  }\n}\n", "/**\n * Override Manager\n *\n * Handles experiment override cookies for testing and development\n *\n * @module OverrideManager\n */\n\nimport { Logger } from '../utils/logger'\n\nexport interface OverrideValue {\n  variant: number\n  env?: number\n  id?: number\n}\n\nexport interface ParsedOverrides {\n  overrides: Record<string, number | OverrideValue>\n  devEnv: string | null\n}\n\nexport class OverrideManager {\n  private cookieName: string\n\n  constructor(cookieName: string = 'absmartly_overrides') {\n    this.cookieName = cookieName\n  }\n\n  /**\n   * Parse cookie overrides from cookie value string\n   *\n   * Format examples:\n   * - Simple: \"exp1:0,exp2:1\" - just variant numbers\n   * - With env: \"exp1:0.1,exp2:1.2\" - variant.env\n   * - Full: \"exp1:0.1.123,exp2:1.2.456\" - variant.env.id\n   * - With devEnv: \"devEnv=https://example.com|exp1:0,exp2:1\"\n   */\n  parseCookieOverrides(cookieValue: string): ParsedOverrides {\n    if (!cookieValue) {\n      return { overrides: {}, devEnv: null }\n    }\n\n    try {\n      let devEnv: string | null = null\n      let experimentsStr = cookieValue\n\n      // Check if dev environment is included\n      if (cookieValue.startsWith('devEnv=')) {\n        const parts = cookieValue.split('|')\n        devEnv = decodeURIComponent(parts[0].substring(7)) // Remove 'devEnv=' prefix\n        experimentsStr = parts[1] || ''\n      }\n\n      const overrides: Record<string, number | OverrideValue> = {}\n\n      if (experimentsStr) {\n        // NEW FORMAT: comma separates experiments, dot separates values within each experiment\n        const experiments = experimentsStr.split(',')\n\n        for (const exp of experiments) {\n          const [name, values] = exp.split(':')\n          if (!name || !values) continue\n\n          const decodedName = decodeURIComponent(name)\n          const parts = values.split('.')\n\n          if (parts.length === 1) {\n            // Simple format: just variant (running experiment)\n            overrides[decodedName] = parseInt(parts[0], 10)\n          } else if (parts.length === 2) {\n            // Format: variant.env\n            overrides[decodedName] = {\n              variant: parseInt(parts[0], 10),\n              env: parseInt(parts[1], 10)\n            }\n          } else {\n            // Full format: variant.env.id\n            overrides[decodedName] = {\n              variant: parseInt(parts[0], 10),\n              env: parseInt(parts[1], 10),\n              id: parseInt(parts[2], 10)\n            }\n          }\n        }\n      }\n\n      return { overrides, devEnv }\n    } catch (error) {\n      Logger.warn('[ABsmartly Extension] Failed to parse override cookie:', error)\n      return { overrides: {}, devEnv: null }\n    }\n  }\n\n  /**\n   * Check for override cookie and log its presence\n   *\n   * Note: The OverridesPlugin handles actual application of overrides.\n   * This function just checks if the cookie exists and logs metadata.\n   */\n  checkOverridesCookie(): void {\n    try {\n      // Just check if cookie exists - OverridesPlugin handles all parsing and application\n      const row = document.cookie\n        .split('; ')\n        .find((row) => row.startsWith(`${this.cookieName}=`))\n\n      let cookieValue: string | undefined\n      if (row) {\n        // Use substring to preserve values with = signs\n        const eqIndex = row.indexOf('=')\n        if (eqIndex !== -1) {\n          cookieValue = row.substring(eqIndex + 1)\n        }\n      }\n\n      if (cookieValue) {\n        Logger.log(\n          '[ABsmartly Extension] Found absmartly_overrides cookie (will be handled by OverridesPlugin)'\n        )\n\n        // Log if development environment is present (just for debugging)\n        if (cookieValue.startsWith('devEnv=')) {\n          const devEnvMatch = cookieValue.match(/^devEnv=([^|]+)/)\n          if (devEnvMatch) {\n            Logger.log(\n              '[ABsmartly Extension] Development environment in cookie:',\n              decodeURIComponent(devEnvMatch[1])\n            )\n          }\n        }\n      } else {\n        Logger.log('[ABsmartly Extension] No experiment overrides cookie found')\n      }\n    } catch (error) {\n      Logger.error('[ABsmartly Extension] Error checking overrides cookie:', error)\n    }\n  }\n\n  /**\n   * Get the current override cookie value\n   */\n  getCookieValue(): string | null {\n    try {\n      const row = document.cookie\n        .split('; ')\n        .find((row) => row.startsWith(`${this.cookieName}=`))\n\n      if (!row) return null\n\n      // Use substring to preserve values with = signs\n      const eqIndex = row.indexOf('=')\n      if (eqIndex === -1) return null\n\n      const value = row.substring(eqIndex + 1)\n      return value || null\n    } catch (error) {\n      Logger.error('[ABsmartly Extension] Error getting cookie value:', error)\n      return null\n    }\n  }\n\n  /**\n   * Get parsed overrides from cookie\n   */\n  getOverrides(): ParsedOverrides {\n    const cookieValue = this.getCookieValue()\n    if (!cookieValue) {\n      return { overrides: {}, devEnv: null }\n    }\n\n    return this.parseCookieOverrides(cookieValue)\n  }\n}\n", "/**\n * Core Orchestrator\n *\n * Coordinates SDK detection, plugin initialization, and message handling\n *\n * @module Orchestrator\n */\n\nimport { Logger } from '../utils/logger'\nimport { SDKDetector } from '../sdk/sdk-detector'\nimport { PluginDetector } from '../sdk/plugin-detector'\nimport { SDKInterceptor } from '../sdk/sdk-interceptor'\nimport { CodeInjector } from '../experiment/code-injector'\nimport { OverrideManager } from '../experiment/override-manager'\n\nexport interface OrchestratorConfig {\n  maxAttempts?: number\n  attemptInterval?: number\n  debug?: boolean\n}\n\nexport interface InitializationState {\n  isInitializing: boolean\n  isInitialized: boolean\n  cachedContext: any | null\n  contextPropertyPath: string | null\n}\n\nexport class Orchestrator {\n  private config: Required<OrchestratorConfig>\n  private state: InitializationState\n  private sdkDetector: SDKDetector\n  private pluginDetector: PluginDetector\n  private sdkInterceptor: SDKInterceptor\n  private codeInjector: CodeInjector\n  private overrideManager: OverrideManager\n  private messageListenerSet: boolean = false\n\n  constructor(config: OrchestratorConfig = {}) {\n    this.config = {\n      maxAttempts: config.maxAttempts || 50, // 5 seconds at 100ms intervals\n      attemptInterval: config.attemptInterval || 100,\n      debug: config.debug !== false\n    }\n\n    this.state = {\n      isInitializing: false,\n      isInitialized: false,\n      cachedContext: null,\n      contextPropertyPath: null\n    }\n\n    this.sdkDetector = new SDKDetector()\n    this.pluginDetector = new PluginDetector()\n    this.sdkInterceptor = new SDKInterceptor({\n      onSDKEvent: (eventName, data) => {\n        this.handleSDKEvent(eventName, data)\n      }\n    })\n    this.codeInjector = new CodeInjector()\n    this.overrideManager = new OverrideManager()\n  }\n\n  /**\n   * Start the initialization process\n   */\n  start(): void {\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => this.waitForSDKAndInitialize())\n    } else {\n      // Give the page a moment to initialize its SDK\n      setTimeout(() => this.waitForSDKAndInitialize(), 100)\n    }\n  }\n\n  /**\n   * Wait for SDK and initialize\n   */\n  private waitForSDKAndInitialize(): void {\n    Logger.log('[ABsmartly Extension] \\u{1F680} waitForSDKAndInitialize started')\n\n    let attempts = 0\n\n    const checkAndInit = (): void => {\n      attempts++\n      Logger.log(`[ABsmartly Extension] \\u{1F50D} Check attempt ${attempts}/${this.config.maxAttempts}`)\n\n      // Detect context only once\n      if (!this.state.cachedContext) {\n        Logger.log('[ABsmartly Extension] \\u{1F50E} No cached context, detecting SDK...')\n        this.detectAndCacheContext()\n      } else {\n        Logger.log('[ABsmartly Extension] \\u2705 Using cached context')\n      }\n\n      // Log context data when found (but only if context is ready)\n      if (this.state.cachedContext && this.state.cachedContext.data && typeof this.state.cachedContext.data === 'function') {\n        // Use ready() promise to wait for context to be ready before accessing data\n        if (this.state.cachedContext.ready && typeof this.state.cachedContext.ready === 'function') {\n          this.state.cachedContext.ready()\n            .then(() => {\n              try {\n                const data = this.state.cachedContext.data()\n                Logger.log('[ABsmartly Extension] Context data on init:', data)\n                Logger.log('[ABsmartly Extension] Experiments available:', data?.experiments ? Object.keys(data.experiments) : 'none')\n              } catch (error: any) {\n                Logger.log('[ABsmartly Extension] Error accessing context data:', error.message)\n              }\n            })\n            .catch((error: any) => {\n              Logger.log('[ABsmartly Extension] Context ready() failed:', error.message)\n            })\n        }\n      }\n\n      // Check if plugin is already loaded (uses cached context)\n      const existingPlugin = this.pluginDetector.detectPlugin(this.state.cachedContext)\n      if (existingPlugin) {\n        if (existingPlugin === 'active-but-inaccessible') {\n          Logger.log('[ABsmartly Extension] Plugin is active but we cannot access it to inject custom code')\n          return\n        }\n\n        Logger.log('[ABsmartly Extension] Plugin already loaded, requesting custom code injection only')\n\n        // Plugin is already loaded and registered with context\n        // Store metadata for SDK consumption (OverridesPlugin handles actual application)\n        this.overrideManager.checkOverridesCookie()\n\n        // Request custom code from extension\n        this.sendMessageToExtension({\n          source: 'absmartly-page',\n          type: 'REQUEST_CUSTOM_CODE'\n        })\n        return\n      }\n\n      const context = this.state.cachedContext\n\n      if (context) {\n        Logger.log('[ABsmartly Extension] SDK context found, requesting plugin initialization')\n\n        // Check if context needs to be ready\n        if (context.ready && typeof context.ready === 'function' && context.pending && context.pending()) {\n          Logger.log('[ABsmartly Extension] Context is pending, waiting for it to be ready...')\n          context.ready()\n            .then(() => {\n              Logger.log('[ABsmartly Extension] Context is now ready after waiting')\n              const data = context.data ? context.data() : null\n              Logger.log('[ABsmartly Extension] Context data after ready:', data)\n              Logger.log('[ABsmartly Extension] Experiments after ready:', data?.experiments ? Object.keys(data.experiments) : 'none')\n            })\n            .catch((err: any) => {\n              Logger.error('[ABsmartly Extension] Error waiting for context:', err)\n            })\n        }\n\n        // Store override metadata for SDK consumption\n        // The OverridesPlugin will handle actual application of overrides\n        this.overrideManager.checkOverridesCookie()\n\n        // Request plugin initialization from extension\n        this.sendMessageToExtension({\n          source: 'absmartly-page',\n          type: 'SDK_CONTEXT_READY'\n        })\n      } else if (attempts < this.config.maxAttempts) {\n        setTimeout(checkAndInit, this.config.attemptInterval)\n      } else {\n        Logger.log('[ABsmartly Extension] No ABsmartly SDK found after 5 seconds')\n      }\n    }\n\n    // Start checking\n    checkAndInit()\n  }\n\n  /**\n   * Detect SDK and cache context\n   */\n  private detectAndCacheContext(): void {\n    const detection = this.sdkDetector.detectSDK()\n\n    if (detection.context && !this.state.cachedContext) {\n      this.state.cachedContext = detection.context\n      this.state.contextPropertyPath = detection.contextPath || 'unknown'\n\n      Logger.log('[ABsmartly Extension] \\u2705 Context found and cached at:', this.state.contextPropertyPath)\n      Logger.log('[ABsmartly Extension] \\u{1F4CA} Context details:', {\n        hasTreatment: !!detection.context.treatment,\n        hasPeek: !!detection.context.peek,\n        hasData: !!detection.context.data,\n        hasEventLogger: !!detection.context.eventLogger,\n        has_eventLogger: detection.context._eventLogger !== undefined,\n        contextType: typeof detection.context\n      })\n\n      // Intercept eventLogger on this context\n      this.sdkInterceptor.interceptEventLogger(detection.context)\n    } else if (!detection.context) {\n      Logger.warn('[ABsmartly Extension] \\u26A0\\uFE0F No context found after detection')\n    }\n  }\n\n  /**\n   * Setup message listener for extension communication\n   */\n  setupMessageListener(): void {\n    if (this.messageListenerSet) {\n      return\n    }\n\n    this.messageListenerSet = true\n    Logger.log('[ABsmartly Extension] Setting up message listener for extension messages')\n\n    window.addEventListener('message', (event) => {\n      if (!event.data || event.data.source !== 'absmartly-extension') {\n        return\n      }\n\n      Logger.log('[ABsmartly Page] Received message from extension:', event.data)\n\n      this.handleExtensionMessage(event.data)\n    })\n  }\n\n  /**\n   * Handle messages from extension\n   */\n  private handleExtensionMessage(message: any): void {\n    const { type, payload } = message\n\n    switch (type) {\n      case 'APPLY_OVERRIDES':\n        this.handleApplyOverrides(payload)\n        break\n\n      case 'PREVIEW_CHANGES':\n        this.handlePreviewChanges(payload)\n        break\n\n      case 'REMOVE_PREVIEW':\n        this.handleRemovePreview(payload)\n        break\n\n      case 'INITIALIZE_PLUGIN':\n        this.handleInitializePlugin(payload)\n        break\n\n      case 'INJECT_CUSTOM_CODE':\n        Logger.log('[ABsmartly Extension] INJECT_CUSTOM_CODE message received but not used')\n        break\n\n      default:\n        Logger.warn('[ABsmartly Extension] Unknown message type:', type)\n    }\n  }\n\n  /**\n   * Handle apply overrides message\n   */\n  private handleApplyOverrides(payload: any): void {\n    Logger.log('[ABsmartly Page] Applying overrides dynamically')\n    const { overrides } = payload || {}\n\n    // The OverridesPlugin handles override application\n    // We just need to update metadata and reload the page\n    if (overrides) {\n      // Store metadata about overrides\n      this.overrideManager.checkOverridesCookie()\n      // After updating overrides, we need to refresh the page for changes to take effect\n      Logger.log('[ABsmartly Page] Override metadata updated. Page will reload to apply changes.')\n    }\n  }\n\n  /**\n   * Handle preview changes message (delegates to external handler if available)\n   */\n  private handlePreviewChanges(payload: any): void {\n    Logger.log('[ABsmartly Page] Handling PREVIEW_CHANGES message')\n    const { changes, experimentName } = payload || {}\n    const expName = experimentName || '__preview__'\n\n    Logger.log('[ABsmartly Page] Preview changes received for experiment:', expName)\n    Logger.log('[ABsmartly Page] Changes to apply:', changes)\n\n    // This would delegate to preview manager if we had one\n    // For now, just log that we received the request\n    Logger.log('[ABsmartly Page] Preview functionality requires external preview manager')\n  }\n\n  /**\n   * Handle remove preview message (delegates to external handler if available)\n   */\n  private handleRemovePreview(payload: any): void {\n    Logger.log('[ABsmartly Page] Handling REMOVE_PREVIEW message')\n    const { experimentName } = payload || {}\n    const expName = experimentName || '__preview__'\n\n    Logger.log('[ABsmartly Page] Removing preview changes for experiment:', expName)\n\n    // This would delegate to preview manager if we had one\n    // For now, just log that we received the request\n    Logger.log('[ABsmartly Page] Preview removal requires external preview manager')\n  }\n\n  /**\n   * Handle initialize plugin message\n   */\n  private handleInitializePlugin(payload: any): void {\n    // Prevent multiple initializations\n    if (this.state.isInitialized || this.state.isInitializing) {\n      Logger.log('[ABsmartly Extension] Already initialized or initializing, skipping')\n      return\n    }\n\n    this.state.isInitializing = true\n\n    const { config } = payload || {}\n    Logger.log('[ABsmartly Extension] Received config from extension:', config)\n\n    // Check again if plugin is already loaded\n    const existingPlugin = this.pluginDetector.detectPlugin(this.state.cachedContext)\n    if (existingPlugin && existingPlugin !== 'active-but-inaccessible') {\n      // Custom code will be injected via INJECTION_CODE message from the plugin\n      this.state.isInitialized = true\n      this.state.isInitializing = false\n      return\n    }\n\n    // Use cached context (should already be detected by waitForSDKAndInitialize)\n    const context = this.state.cachedContext\n\n    if (!context) {\n      Logger.error('[ABsmartly Extension] No context available for plugin initialization')\n      this.state.isInitializing = false\n      return\n    }\n\n    // Check if plugin is already registered with context\n    if (context.__domPlugin && context.__domPlugin.initialized) {\n      Logger.log('[ABsmartly Extension] Plugin already initialized via context.__domPlugin')\n      this.state.isInitializing = false\n      return\n    }\n\n    // Inject experiment code\n    try {\n      Logger.log('[ABsmartly Extension] Checking for experiment-specific injection code')\n      this.codeInjector.injectExperimentCode(context)\n    } catch (error) {\n      Logger.error('[ABsmartly Extension] Failed to inject experiment code:', error)\n    }\n\n    // Notify extension that initialization is complete\n    this.sendMessageToExtension({\n      source: 'absmartly-page',\n      type: 'PLUGIN_INITIALIZED',\n      payload: {\n        version: '1.0.0',\n        capabilities: ['code-injection']\n      }\n    })\n\n    this.state.isInitialized = true\n    this.state.isInitializing = false\n  }\n\n  /**\n   * Handle SDK event\n   */\n  private handleSDKEvent(eventName: string, data: any): void {\n    Logger.log('[ABsmartly Extension] \\u{1F514} SDK Event:', { eventName, data })\n\n    // Send to extension\n    this.sendMessageToExtension({\n      source: 'absmartly-page',\n      type: 'SDK_EVENT',\n      payload: {\n        eventName,\n        data,\n        timestamp: new Date().toISOString()\n      }\n    })\n  }\n\n  /**\n   * Send message to extension\n   */\n  private sendMessageToExtension(message: any): void {\n    // Always send via window.postMessage (content script will relay to background)\n    window.postMessage(message, '*')\n  }\n\n  /**\n   * Get cached context\n   */\n  getContext(): any | null {\n    return this.state.cachedContext\n  }\n\n  /**\n   * Get initialization state\n   */\n  getState(): InitializationState {\n    return { ...this.state }\n  }\n\n  /**\n   * Expose variant assignments getter for extension\n   */\n  exposeVariantAssignments(): void {\n    (window as any).__absmartlyGetVariantAssignments = async (experimentNames: string[]) => {\n      Logger.log('[ABsmartly Extension] Getting variant assignments for:', experimentNames)\n\n      const context = this.state.cachedContext || this.sdkDetector.detectSDK().context\n\n      if (!context) {\n        Logger.warn('[ABsmartly Extension] No context available for getting variants')\n        return { assignments: {}, experimentsInContext: [] }\n      }\n\n      // Check if context is ready, if not wait for it\n      if (context.ready && typeof context.ready === 'function') {\n        try {\n          await context.ready()\n        } catch (error) {\n          Logger.warn('[ABsmartly Extension] Error waiting for context ready:', error)\n        }\n      }\n\n      // Get experiments that exist in the context data\n      let experimentsInContext: string[] = []\n      if (context.data && typeof context.data === 'function') {\n        const contextData = context.data()\n        if (contextData?.experiments) {\n          experimentsInContext = Object.keys(contextData.experiments)\n        }\n      }\n\n      const assignments: Record<string, number> = {}\n      for (const expName of experimentNames) {\n        try {\n          if (typeof context.peek === 'function') {\n            const variant = context.peek(expName)\n\n            // Only include valid variant assignments (not -1, null, or undefined)\n            // But DO include 0 as it's a valid variant\n            if (variant !== undefined && variant !== null && variant !== -1) {\n              assignments[expName] = variant\n            }\n          }\n        } catch (error) {\n          Logger.warn(`[ABsmartly Extension] Failed to peek experiment ${expName}:`, error)\n        }\n      }\n\n      return { assignments, experimentsInContext }\n    }\n  }\n\n  /**\n   * Expose context path getter for extension\n   */\n  exposeContextPath(): void {\n    (window as any).__absmartlyGetContextPath = () => {\n      // First detect SDK if not already cached\n      if (!this.state.cachedContext) {\n        this.detectAndCacheContext()\n      }\n\n      return {\n        found: !!this.state.cachedContext,\n        path: this.state.contextPropertyPath || null,\n        hasContext: !!this.state.cachedContext,\n        hasPeek: !!(this.state.cachedContext && typeof this.state.cachedContext.peek === 'function'),\n        hasTreatment: !!(this.state.cachedContext && typeof this.state.cachedContext.treatment === 'function')\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["row"]
}

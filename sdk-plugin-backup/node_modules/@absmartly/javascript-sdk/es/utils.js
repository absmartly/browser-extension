"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chooseVariant = exports.hashUnit = exports.base64UrlNoPadding = exports.stringToUint8Array = exports.arrayEqualsShallow = exports.isEqualsDeep = exports.isPromise = exports.isObject = exports.isNumeric = exports.isWorker = exports.isLongLivedApp = exports.getApplicationVersion = exports.getApplicationName = void 0;
const md5_1 = require("./md5");
const getApplicationName = app => typeof app !== "string" ? app.name : app;
exports.getApplicationName = getApplicationName;
const getApplicationVersion = app => typeof app !== "string" ? app.version : 0;
exports.getApplicationVersion = getApplicationVersion;
function isBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
}
function isReactNative() {
  return typeof navigator !== "undefined" && navigator.product === "ReactNative";
}
function isLongLivedApp() {
  return isBrowser() || isReactNative();
}
exports.isLongLivedApp = isLongLivedApp;
function isWorker() {
  return typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
}
exports.isWorker = isWorker;
function isNumeric(value) {
  return typeof value === "number";
}
exports.isNumeric = isNumeric;
function isObject(value) {
  if (!(value instanceof Object)) {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto == null || proto === Object.prototype;
}
exports.isObject = isObject;
function isPromise(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
exports.isPromise = isPromise;
function arrayEqualsDeep(a, b, astack = [], bstack = []) {
  var _a;
  let len = (_a = astack === null || astack === void 0 ? void 0 : astack.length) !== null && _a !== void 0 ? _a : 0;
  while (len--) {
    if (astack[len] === a) return bstack[len] === b;
  }
  astack = astack !== null && astack !== void 0 ? astack : [];
  bstack = bstack !== null && bstack !== void 0 ? bstack : [];
  astack.push(a);
  bstack.push(b);
  len = a.length;
  while (len--) {
    if (!isEqualsDeep(a[len], b[len], astack, bstack)) return false;
  }
  bstack.pop();
  astack.pop();
  return true;
}
function objectEqualsDeep(a, b, keys, astack, bstack) {
  var _a;
  let len = (_a = astack === null || astack === void 0 ? void 0 : astack.length) !== null && _a !== void 0 ? _a : 0;
  while (len--) {
    if (astack && astack[len] === a) return bstack && bstack[len] === b;
  }
  astack = astack !== null && astack !== void 0 ? astack : [];
  bstack = bstack !== null && bstack !== void 0 ? bstack : [];
  astack.push(a);
  bstack.push(b);
  len = keys.length;
  while (len--) {
    const key = keys[len];
    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
    if (!isEqualsDeep(a[key], b[key], astack, bstack)) return false;
  }
  bstack.pop();
  astack.pop();
  return true;
}
function isEqualsDeep(a, b, astack, bstack) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  switch (typeof a) {
    case "boolean":
      return a === b;
    case "number":
      if (Number.isNaN(a)) return Number.isNaN(b);
      return a === b;
    case "string":
      return a === b;
    case "object":
      {
        const arrays = Array.isArray(a);
        if (arrays && !Array.isArray(b)) return false;
        const objects = isObject(a);
        if (objects && !isObject(b)) return false;
        if (!arrays && !objects) return false;
        if (arrays && Array.isArray(b)) {
          if (a.length === b.length) {
            return arrayEqualsDeep(a, b, astack, bstack);
          }
        } else {
          if (a && b) {
            const keys = Object.keys(a);
            if (keys.length === Object.keys(b).length) {
              return objectEqualsDeep(a, b, keys, astack, bstack);
            }
          }
        }
        break;
      }
    default:
      break;
  }
  return false;
}
exports.isEqualsDeep = isEqualsDeep;
function arrayEqualsShallow(a, b) {
  return a === b || (a === null || a === void 0 ? void 0 : a.length) === (b === null || b === void 0 ? void 0 : b.length) && !(a === null || a === void 0 ? void 0 : a.some((va, vi) => b && va !== b[vi]));
}
exports.arrayEqualsShallow = arrayEqualsShallow;
function stringToUint8Array(value) {
  const n = value.length;
  const array = new Array(value.length);
  let k = 0;
  for (let i = 0; i < n; ++i) {
    const c = value.charCodeAt(i);
    if (c < 0x80) {
      array[k++] = c;
    } else if (c < 0x800) {
      array[k++] = c >> 6 | 192;
      array[k++] = c & 63 | 128;
    } else {
      array[k++] = c >> 12 | 224;
      array[k++] = c >> 6 & 63 | 128;
      array[k++] = c & 63 | 128;
    }
  }
  return Uint8Array.from(array);
}
exports.stringToUint8Array = stringToUint8Array;
const Base64URLNoPaddingChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function base64UrlNoPadding(value) {
  const chars = Base64URLNoPaddingChars;
  const remaining = value.byteLength % 3;
  const encodeLen = (value.byteLength / 3 | 0) * 4 + (remaining === 0 ? 0 : remaining === 1 ? 2 : 3);
  const result = new Array(encodeLen);
  let i;
  let out = 0;
  const len = value.byteLength - remaining;
  for (i = 0; i < len; i += 3) {
    const bytes = value[i] << 16 | value[i + 1] << 8 | value[i + 2];
    result[out] = chars[bytes >> 18 & 63];
    result[out + 1] = chars[bytes >> 12 & 63];
    result[out + 2] = chars[bytes >> 6 & 63];
    result[out + 3] = chars[bytes & 63];
    out += 4;
  }
  switch (remaining) {
    case 2:
      {
        const bytes = value[i] << 16 | value[i + 1] << 8;
        result[out] = chars[bytes >> 18 & 63];
        result[out + 1] = chars[bytes >> 12 & 63];
        result[out + 2] = chars[bytes >> 6 & 63];
      }
      break;
    case 1:
      {
        const bytes = value[i] << 16;
        result[out] = chars[bytes >> 18 & 63];
        result[out + 1] = chars[bytes >> 12 & 63];
      }
      break;
    default:
      break;
  }
  return result.join("");
}
exports.base64UrlNoPadding = base64UrlNoPadding;
function hashUnit(value) {
  const unit = typeof value === "string" ? value : value.toFixed(0);
  return base64UrlNoPadding((0, md5_1.md5)(stringToUint8Array(unit).buffer));
}
exports.hashUnit = hashUnit;
function chooseVariant(split, prob) {
  let cumSum = 0.0;
  for (let i = 0; i < split.length; ++i) {
    cumSum += split[i];
    if (prob < cumSum) {
      return i;
    }
  }
  return split.length - 1;
}
exports.chooseVariant = chooseVariant;
/**
 * Visual Editor Main Script
 * This gets bundled and injected into the page context
 */

import { generateRobustSelector } from '../utils/selector-generator'
import StateManager, { VisualEditorConfig } from './modules/state-manager'
import EventHandlers from './modules/event-handlers'
import ContextMenu from './modules/context-menu'
import ChangeTracker from './modules/change-tracking'
import UIComponents from './modules/ui-components'
import EditModes from './modules/edit-modes'
import Cleanup from './modules/cleanup'

class VisualEditor {
  private stateManager: StateManager
  private eventHandlers: EventHandlers
  private contextMenu: ContextMenu
  private changeTracker: ChangeTracker
  private uiComponents: UIComponents
  private editModes: EditModes
  private cleanup: Cleanup

  constructor(config: VisualEditorConfig) {
    // Initialize state manager
    this.stateManager = new StateManager(config)

    // Initialize modules
    this.eventHandlers = new EventHandlers(this.stateManager)
    this.contextMenu = new ContextMenu(this.stateManager)
    this.changeTracker = new ChangeTracker(this.stateManager)
    this.uiComponents = new UIComponents(this.stateManager)
    this.editModes = new EditModes(this.stateManager)
    this.cleanup = new Cleanup(this.stateManager)

    // Setup integrations between modules
    this.setupModuleIntegrations()
  }

  private setupModuleIntegrations(): void {
    // Connect event handlers to context menu
    this.eventHandlers.showContextMenu = (x: number, y: number, element: Element) => {
      this.contextMenu.show(x, y, element)
    }

    // Connect context menu to other modules
    this.contextMenu.handleAction = (action: string, element: Element) => {
      this.handleMenuAction(action, element)
    }

    // Connect UI components to change tracker
    this.uiComponents.onUndo = () => this.changeTracker.performUndo()
    this.uiComponents.onRedo = () => this.changeTracker.performRedo()

    // Register cleanup handlers
    this.cleanup.registerEventHandler(() => this.eventHandlers.detachEventListeners())
  }

  start(): { success: boolean; already?: boolean } {
    // Check if we already have the editor
    if ((window as any).__absmartlyVisualEditorActive) {
      console.log('[ABSmartly] Visual editor already active')
      return { already: true }
    }

    console.log('[ABSmartly] Starting visual editor')

    // Mark as active
    ;(window as any).__absmartlyVisualEditorActive = true

    // Hide preview header when visual editor starts
    const previewHeader = document.getElementById('absmartly-preview-header')
    if (previewHeader) {
      previewHeader.style.display = 'none'
    }

    // Create UI
    this.uiComponents.createBanner()
    this.addGlobalStyles()

    // Attach event listeners
    this.eventHandlers.attachEventListeners()

    // Setup global keyboard handlers
    this.setupKeyboardHandlers()

    // Setup message handlers for extension communication
    this.setupMessageHandlers()

    console.log('[ABSmartly] Visual editor is now active!')
    return { success: true }
  }

  private handleMenuAction(action: string, element: Element): void {
    const originalState = {
      html: element.outerHTML,
      parent: element.parentElement,
      nextSibling: element.nextElementSibling,
      textContent: element.textContent
    }

    switch (action) {
      case 'edit':
        this.handleEditAction(element, originalState)
        break

      case 'editHtml':
        this.handleEditHtmlAction(element, originalState)
        break

      case 'rearrange':
        this.editModes.enableRearrangeMode(element)
        break

      case 'resize':
        this.editModes.enableResizeMode(element)
        break

      case 'inlineEdit':
        this.handleInlineEditAction(element, originalState)
        break

      case 'hide':
        ;(element as HTMLElement).style.display = 'none'
        this.changeTracker.trackChange('hide', element, { display: 'none' })
        break

      case 'delete':
        element.remove()
        this.changeTracker.trackChange('delete', null, {
          deletedHtml: originalState.html,
          parent: originalState.parent,
          nextSibling: originalState.nextSibling
        })
        break

      case 'copy':
        navigator.clipboard.writeText(element.outerHTML).then(() => {
          this.uiComponents.showNotification('Element HTML copied to clipboard!')
        })
        break

      case 'copySelector':
        const selector = generateRobustSelector(element, {
          preferDataAttributes: false,
          avoidAutoGenerated: true,
          includeParentContext: true,
          maxParentLevels: 3
        })
        navigator.clipboard.writeText(selector).then(() => {
          this.uiComponents.showNotification(`Selector copied: ${selector}`)
        })
        break

      default:
        console.log('[ABSmartly] Action not yet implemented:', action)
        this.uiComponents.showNotification(`${action}: Coming soon!`)
    }
  }

  private handleEditAction(element: Element, originalState: any): void {
    // Close menu immediately when starting edit
    const existingMenu = document.getElementById('absmartly-menu-host')
    if (existingMenu) existingMenu.remove()

    // Mark as modified when editing starts
    ;(element as HTMLElement).dataset.absmartlyModified = 'true'

    // Prevent link navigation during editing
    const preventDefault = (e: Event) => {
      if (this.eventHandlers.isEditingMode) {
        e.preventDefault()
        e.stopPropagation()
      }
    }
    element.addEventListener('click', preventDefault, true)

    // Remove selection styling while editing
    element.classList.remove('absmartly-selected')
    element.classList.add('absmartly-editing')
    ;(element as HTMLElement).contentEditable = 'true'
    ;(element as HTMLElement).focus()

    // Select all text for easy replacement
    const range = document.createRange()
    range.selectNodeContents(element)
    const selection = window.getSelection()
    selection?.removeAllRanges()
    selection?.addRange(range)

    this.eventHandlers.setEditing(true)

    const handleBlur = () => {
      ;(element as HTMLElement).contentEditable = 'false'
      element.classList.remove('absmartly-editing')
      element.classList.add('absmartly-selected')
      this.eventHandlers.setEditing(false)
      element.removeEventListener('blur', handleBlur)
      element.removeEventListener('keydown', handleKeyPress)
      element.removeEventListener('click', preventDefault, true)

      // Track change with original text for restoration
      this.changeTracker.trackChange('edit', element, {
        oldText: originalState.textContent,
        newText: element.textContent,
        originalHtml: originalState.html
      })
    }

    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault()
        ;(element as HTMLElement).blur()
      }
      if (e.key === 'Escape') {
        // Restore original text
        element.textContent = originalState.textContent
        ;(element as HTMLElement).blur()
      }
    }

    element.addEventListener('blur', handleBlur)
    element.addEventListener('keydown', handleKeyPress)
  }

  private async handleEditHtmlAction(element: Element, originalState: any): Promise<void> {
    const currentHtml = element.outerHTML
    const newHtml = await this.uiComponents.createHtmlEditor(element, currentHtml)

    if (newHtml && newHtml !== currentHtml) {
      const tempDiv = document.createElement('div')
      tempDiv.innerHTML = newHtml
      const newElement = tempDiv.firstElementChild
      if (newElement) {
        element.replaceWith(newElement)
        this.changeTracker.trackChange('editHtml', newElement, {
          oldHtml: currentHtml,
          newHtml: newHtml
        })
      }
    }
  }

  private handleInlineEditAction(element: Element, originalState: any): void {
    element.classList.add('absmartly-editing')
    ;(element as HTMLElement).contentEditable = 'true'
    ;(element as HTMLElement).focus()

    const range = document.createRange()
    range.selectNodeContents(element)
    const selection = window.getSelection()
    selection?.removeAllRanges()
    selection?.addRange(range)

    this.eventHandlers.setEditing(true)

    const finishInlineEdit = () => {
      ;(element as HTMLElement).contentEditable = 'false'
      element.classList.remove('absmartly-editing')
      this.eventHandlers.setEditing(false)
      this.changeTracker.trackChange('edit', element, {
        oldText: originalState.textContent,
        newText: element.textContent
      })
    }

    element.addEventListener('blur', finishInlineEdit, { once: true })
    element.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === 'Escape') {
        e.preventDefault()
        ;(element as HTMLElement).blur()
      }
    })
  }

  private addGlobalStyles(): void {
    const style = document.createElement('style')
    style.dataset.absmartly = 'true'
    style.textContent = `
      .absmartly-hover {
        outline: 2px solid #3b82f6 !important;
        outline-offset: 2px !important;
      }
      .absmartly-selected {
        outline: 3px solid #10b981 !important;
        outline-offset: 2px !important;
      }
      .absmartly-editing {
        outline: 3px solid #f59e0b !important;
        outline-offset: 2px !important;
        background: rgba(245, 158, 11, 0.1) !important;
      }
      .absmartly-draggable {
        cursor: move !important;
        opacity: 0.8 !important;
      }
      .absmartly-dragging {
        opacity: 0.5 !important;
      }
      .absmartly-drop-target {
        outline: 2px dashed #10b981 !important;
        outline-offset: 4px !important;
        background: rgba(16, 185, 129, 0.1) !important;
      }
      .absmartly-resize-active {
        outline: 3px solid #8b5cf6 !important;
        outline-offset: 2px !important;
      }
    `
    document.head.appendChild(style)
  }

  private setupKeyboardHandlers(): void {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Undo: Ctrl+Z (Cmd+Z on Mac)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault()
        this.changeTracker.performUndo()
      }

      // Redo: Ctrl+Y or Ctrl+Shift+Z (Cmd+Y or Cmd+Shift+Z on Mac)
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault()
        this.changeTracker.performRedo()
      }

      // Copy selector: Ctrl+Shift+C (Cmd+Shift+C on Mac)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'c') {
        e.preventDefault()
        const selectedElement = this.stateManager.getState().selectedElement
        if (selectedElement) {
          const selector = generateRobustSelector(selectedElement, {
            preferDataAttributes: false,
            avoidAutoGenerated: true,
            includeParentContext: true,
            maxParentLevels: 3
          })
          navigator.clipboard.writeText(selector).then(() => {
            this.uiComponents.showNotification(`Selector copied: ${selector}`)
          })
        }
      }

      // Delete: Delete key
      if (e.key === 'Delete') {
        const selectedElement = this.stateManager.getState().selectedElement
        if (selectedElement && !this.eventHandlers.isEditingMode) {
          e.preventDefault()
          selectedElement.remove()
          this.changeTracker.trackChange('delete', null, {
            deletedHtml: selectedElement.outerHTML,
            parent: selectedElement.parentElement
          })
        }
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    this.cleanup.registerEventHandler(() => {
      document.removeEventListener('keydown', handleKeyDown)
    })
  }

  private setupMessageHandlers(): void {
    const handleMessage = (event: MessageEvent) => {
      if (event.source !== window) return

      switch (event.data.type) {
        case 'ABSMARTLY_VISUAL_EDITOR_EXIT':
          this.stop()
          break
      }
    }

    window.addEventListener('message', handleMessage)
    this.cleanup.registerEventHandler(() => {
      window.removeEventListener('message', handleMessage)
    })
  }

  stop(): void {
    console.log('[ABSmartly] Stopping visual editor')
    this.cleanup.cleanupVisualEditor()
  }
}

// Main entry point function
export function initVisualEditor(
  variantName: string,
  experimentName: string,
  logoUrl: string,
  initialChanges: any[]
): { success: boolean; already?: boolean } {
  console.log('[ABSmartly] Initializing visual editor')

  const config: VisualEditorConfig = {
    variantName,
    experimentName,
    logoUrl,
    initialChanges
  }

  const editor = new VisualEditor(config)
  const result = editor.start()

  // Store editor instance globally for potential external access
  ;(window as any).__absmartlyVisualEditor = editor

  return result
}

// Make it available globally for injection
;(window as any).initVisualEditor = initVisualEditor
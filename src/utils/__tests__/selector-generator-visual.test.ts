/**
 * @jest-environment jsdom
 */

import { getSelector, isAutoGenerated } from '../selector-generator-visual'

describe('isAutoGenerated', () => {
  test('should detect ABSmartly-added attributes', () => {
    expect(isAutoGenerated('absmartly-preview')).toBe(true)
    expect(isAutoGenerated('data-ABSmartly-test')).toBe(true)
    expect(isAutoGenerated('normal-id')).toBe(false)
  })

  test('should detect IDs starting with numbers', () => {
    expect(isAutoGenerated('123abc')).toBe(true)
    expect(isAutoGenerated('9test')).toBe(true)
    expect(isAutoGenerated('abc123')).toBe(false)
  })

  test('should detect framework-specific patterns', () => {
    expect(isAutoGenerated('framer-xyz123')).toBe(true)
    expect(isAutoGenerated('css-1a2b3c')).toBe(true)
    expect(isAutoGenerated('sc-aBcDeF123')).toBe(true)
    expect(isAutoGenerated('MuiBox-root-456')).toBe(true)
    expect(isAutoGenerated('emotion-123')).toBe(true)
    expect(isAutoGenerated('chakra-modal')).toBe(true)
    expect(isAutoGenerated('normal-class-name')).toBe(false)
  })

  test('should detect hex strings', () => {
    expect(isAutoGenerated('a1b2c3d4')).toBe(true)
    expect(isAutoGenerated('something_abc123')).toBe(true)
    expect(isAutoGenerated('normal')).toBe(false)
  })
})

describe('getSelector', () => {
  let container: HTMLElement

  beforeEach(() => {
    // Reset DOM for each test
    document.body.innerHTML = ''
    container = document.createElement('div')
    document.body.appendChild(container)
  })

  afterEach(() => {
    document.body.innerHTML = ''
  })

  describe('Unique IDs', () => {
    test('should return ID selector for element with unique ID', () => {
      container.innerHTML = '<div id="unique-header"><h1>Title</h1></div>'
      const h1 = container.querySelector('h1')!
      const selector = getSelector(h1)
      expect(selector).toMatch(/#unique-header/)

      // Verify selector is unique
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(h1)
    })

    test('should use unique ID directly when element has one', () => {
      container.innerHTML = '<div><span id="unique-span">Text</span></div>'
      const span = container.querySelector('span')!
      const selector = getSelector(span)
      expect(selector).toBe('#unique-span')
    })
  })

  describe('Duplicate IDs', () => {
    test('should handle duplicate IDs with parent context', () => {
      container.innerHTML = `
        <div id="product-list">
          <div class="item">
            <div id="price">$10</div>
          </div>
          <div class="item">
            <div id="price">$20</div>
          </div>
        </div>
      `
      const firstPrice = container.querySelectorAll('#price')[0]
      const secondPrice = container.querySelectorAll('#price')[1]

      const firstSelector = getSelector(firstPrice)
      const secondSelector = getSelector(secondPrice)

      // Selectors should be different
      expect(firstSelector).not.toBe(secondSelector)

      // Each should be unique
      expect(document.querySelectorAll(firstSelector)).toHaveLength(1)
      expect(document.querySelectorAll(secondSelector)).toHaveLength(1)

      // Should include parent context
      expect(firstSelector).toMatch(/#product-list/)
      expect(secondSelector).toMatch(/#product-list/)
    })

    test('should use nth-child to disambiguate duplicate IDs', () => {
      container.innerHTML = `
        <div id="list">
          <div><span id="dup">First</span></div>
          <div><span id="dup">Second</span></div>
          <div><span id="dup">Third</span></div>
        </div>
      `
      const spans = container.querySelectorAll('#dup')
      const selectors = Array.from(spans).map(span => getSelector(span))

      // All selectors should be unique
      selectors.forEach((sel, i) => {
        const matches = document.querySelectorAll(sel)
        expect(matches).toHaveLength(1)
        expect(matches[0]).toBe(spans[i])
      })

      // Should use parent ID
      selectors.forEach(sel => {
        expect(sel).toMatch(/#list/)
      })
    })
  })

  describe('Data attributes', () => {
    test('should prefer unique ID over data-testid', () => {
      container.innerHTML = `
        <button id="btn" class="button" data-testid="submit-button">Submit</button>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)
      // Should prefer the unique ID for performance
      expect(selector).toBe('#btn')
    })

    test('should use data-testid when ID is auto-generated', () => {
      container.innerHTML = `
        <button id="css-1a2b3c" data-testid="submit-button">Submit</button>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)
      // Should use data-testid since ID is auto-generated
      expect(selector).toBe('[data-testid="submit-button"]')
    })

    test('should use data-test when data-testid not available', () => {
      container.innerHTML = `
        <input data-test="email-input" type="email">
      `
      const input = container.querySelector('input')!
      const selector = getSelector(input)
      expect(selector).toBe('[data-test="email-input"]')
    })

    test('should ignore data-absmartly attributes', () => {
      container.innerHTML = `
        <div data-absmartly-experiment="test">
          <span>Text</span>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)
      expect(selector).not.toMatch(/data-absmartly/)
    })
  })

  describe('Single children (no unnecessary nth-child)', () => {
    test('should not add nth-child(1) for single child', () => {
      container.innerHTML = `
        <div id="parent">
          <span>Only child</span>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)
      // Now uses descendant selector for better performance
      expect(selector).toBe('#parent span')
      expect(selector).not.toMatch(/:nth-child\(1\)/)
    })

    test('should not add nth-child for single nested child', () => {
      container.innerHTML = `
        <div id="outer">
          <div>
            <p>Only paragraph</p>
          </div>
        </div>
      `
      const p = container.querySelector('p')!
      const selector = getSelector(p)
      expect(selector).not.toMatch(/:nth-child\(1\)/)

      // Should still be unique
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(p)
    })
  })

  describe('Multiple children (needs nth-child)', () => {
    test('should add nth-of-type for multiple siblings when needed', () => {
      container.innerHTML = `
        <div id="parent">
          <span>First</span>
          <span>Second</span>
          <span>Third</span>
        </div>
      `
      const second = container.querySelectorAll('span')[1]
      const selector = getSelector(second)
      // Should use nth-of-type when necessary for uniqueness
      expect(selector).toMatch(/:nth-of-type\(2\)/)

      // Should be unique
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(second)
    })

    test('should handle list items correctly', () => {
      container.innerHTML = `
        <ul id="menu">
          <li><a href="#">Home</a></li>
          <li><a href="#">About</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
      `
      const links = container.querySelectorAll('a')
      const selectors = Array.from(links).map(link => getSelector(link))

      // Each should be unique
      selectors.forEach((sel, i) => {
        const matches = document.querySelectorAll(sel)
        expect(matches).toHaveLength(1)
        expect(matches[0]).toBe(links[i])
      })

      // Should include parent ID
      selectors.forEach(sel => {
        expect(sel).toMatch(/#menu/)
      })
    })
  })

  describe('No brittle single-tag selectors', () => {
    test('should not return single tag like "p" or "span"', () => {
      container.innerHTML = `
        <div id="content">
          <p>Paragraph</p>
        </div>
      `
      const p = container.querySelector('p')!
      const selector = getSelector(p)
      expect(selector).not.toBe('p')
      // Should use descendant selector for performance
      expect(selector).toBe('#content p')
    })

    test('should include context even for seemingly unique elements', () => {
      container.innerHTML = `
        <article>
          <h1>Title</h1>
        </article>
      `
      const h1 = container.querySelector('h1')!
      const selector = getSelector(h1)
      expect(selector).not.toBe('h1')
      // Should add parent context for structural elements
      expect(selector).toBe('article > h1')
    })
  })

  describe('Auto-generated IDs', () => {
    test('should ignore auto-generated IDs', () => {
      container.innerHTML = `
        <div id="css-1a2b3c">
          <div id="framer-xyz">
            <span>Text</span>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)
      expect(selector).not.toMatch(/css-1a2b3c/)
      expect(selector).not.toMatch(/framer-xyz/)
    })

    test('should ignore ABSmartly-added IDs', () => {
      container.innerHTML = `
        <div id="absmartly-preview">
          <p>Content</p>
        </div>
      `
      const p = container.querySelector('p')!
      const selector = getSelector(p)
      expect(selector).not.toMatch(/absmartly/)
    })
  })

  describe('Complex nested structures', () => {
    test('should create minimal selectors for deeply nested elements', () => {
      container.innerHTML = `
        <div id="root">
          <div>
            <div>
              <div>
                <span>Deep</span>
              </div>
            </div>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should start with root ID
      expect(selector).toMatch(/^#root/)

      // Should not have too many intermediate divs
      const divCount = (selector.match(/\bdiv\b/g) || []).length
      expect(divCount).toBeLessThanOrEqual(3)

      // Should be unique
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(span)
    })

    test('should handle complex e-commerce layouts', () => {
      container.innerHTML = `
        <div id="products">
          <div class="row">
            <div class="col">
              <div class="card">
                <span class="price">$99</span>
              </div>
            </div>
            <div class="col">
              <div class="card">
                <span class="price">$199</span>
              </div>
            </div>
          </div>
        </div>
      `
      const prices = container.querySelectorAll('.price')
      const selectors = Array.from(prices).map(price => getSelector(price))

      // Each should be unique
      selectors.forEach((sel, i) => {
        const matches = document.querySelectorAll(sel)
        expect(matches).toHaveLength(1)
        expect(matches[0]).toBe(prices[i])
      })

      // Should use parent ID
      selectors.forEach(sel => {
        expect(sel).toMatch(/#products/)
      })
    })
  })

  describe('Edge cases', () => {
    test('should handle empty element', () => {
      expect(getSelector(null as any)).toBe('')
    })

    test('should handle body element', () => {
      const selector = getSelector(document.body)
      expect(selector).toBeTruthy()
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(document.body)
    })

    test('should handle elements with special characters in IDs', () => {
      container.innerHTML = `<div id="test:id"><span>Text</span></div>`
      const span = container.querySelector('span')!
      // Should escape or handle special chars properly
      const selector = getSelector(span)
      expect(() => document.querySelector(selector)).not.toThrow()
    })
  })
})
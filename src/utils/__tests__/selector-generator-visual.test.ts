/**
 * @jest-environment jsdom
 */

import { getSelector, isAutoGenerated } from '../selector-generator-visual'

describe('isAutoGenerated', () => {
  test('should detect ABSmartly-added attributes', () => {
    expect(isAutoGenerated('absmartly-preview')).toBe(true)
    expect(isAutoGenerated('data-ABSmartly-test')).toBe(true)
    expect(isAutoGenerated('absmartly-selected')).toBe(true)
    expect(isAutoGenerated('normal-id')).toBe(false)
  })

  test('should detect IDs starting with numbers', () => {
    expect(isAutoGenerated('123abc')).toBe(true)
    expect(isAutoGenerated('9test')).toBe(true)
    expect(isAutoGenerated('0nd0iSQcMZb94MDr')).toBe(true)
    expect(isAutoGenerated('abc123')).toBe(false)
  })

  test('should detect framework-specific patterns', () => {
    expect(isAutoGenerated('framer-xyz123')).toBe(true)
    expect(isAutoGenerated('css-1a2b3c')).toBe(true)
    expect(isAutoGenerated('css-1a2b3c4')).toBe(true)
    expect(isAutoGenerated('sc-aBcDeF123')).toBe(true)
    expect(isAutoGenerated('MuiBox-root-456')).toBe(true)
    expect(isAutoGenerated('emotion-123')).toBe(true)
    expect(isAutoGenerated('chakra-modal')).toBe(true)
    expect(isAutoGenerated('svelte-xyz789')).toBe(true)
    expect(isAutoGenerated('v-12345678')).toBe(true)
    expect(isAutoGenerated('normal-class-name')).toBe(false)
  })

  test('should detect hex strings and random patterns', () => {
    expect(isAutoGenerated('a1b2c3d4')).toBe(true)
    expect(isAutoGenerated('a1b2c3d4e5f6')).toBe(true)
    expect(isAutoGenerated('something_abc123def')).toBe(true)
    expect(isAutoGenerated('test_6h6XQ')).toBe(true)
    expect(isAutoGenerated('normal')).toBe(false)
    expect(isAutoGenerated('user-profile')).toBe(false)
  })
})

describe('getSelector - Performance Priority', () => {
  let container: HTMLElement

  beforeEach(() => {
    document.body.innerHTML = ''
    container = document.createElement('div')
    document.body.appendChild(container)
  })

  afterEach(() => {
    document.body.innerHTML = ''
  })

  describe('Priority 1: Unique IDs (fastest)', () => {
    test('should return ID selector for element with unique ID', () => {
      container.innerHTML = '<div id="unique-header"><h1>Title</h1></div>'
      const h1 = container.querySelector('h1')!
      const selector = getSelector(h1)

      // Should use parent ID with descendant selector for performance
      expect(selector).toBe('#unique-header h1')

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(h1)
    })

    test('should use unique ID directly when element has one', () => {
      container.innerHTML = '<div><span id="unique-span">Text</span></div>'
      const span = container.querySelector('span')!
      const selector = getSelector(span)
      expect(selector).toBe('#unique-span')
    })

    test('should escape special characters in IDs', () => {
      container.innerHTML = '<div id="test:id"><span>Text</span></div>'
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should handle special chars properly
      expect(() => document.querySelector(selector)).not.toThrow()

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(span)
    })
  })

  describe('Priority 2: Duplicate IDs with simple parent (1.08x slower)', () => {
    test('should handle duplicate IDs with parent context', () => {
      container.innerHTML = `
        <div id="product-list">
          <div class="item">
            <div id="price">$10</div>
          </div>
          <div class="item">
            <div id="price">$20</div>
          </div>
        </div>
      `
      const firstPrice = container.querySelectorAll('#price')[0]
      const secondPrice = container.querySelectorAll('#price')[1]

      const firstSelector = getSelector(firstPrice)
      const secondSelector = getSelector(secondPrice)

      // Should use simple descendant selectors for performance
      expect(firstSelector).toContain('#product-list')
      expect(secondSelector).toContain('#product-list')

      // Selectors should be different
      expect(firstSelector).not.toBe(secondSelector)

      // Each should be unique
      expect(document.querySelectorAll(firstSelector)).toHaveLength(1)
      expect(document.querySelectorAll(secondSelector)).toHaveLength(1)
    })

    test('should disambiguate duplicate IDs at same level', () => {
      container.innerHTML = `
        <div id="container">
          <div id="dup-id">First</div>
          <div id="dup-id">Second</div>
          <div id="dup-id">Third</div>
        </div>
      `
      const first = container.querySelectorAll('#dup-id')[0]
      const second = container.querySelectorAll('#dup-id')[1]
      const third = container.querySelectorAll('#dup-id')[2]

      const firstSelector = getSelector(first)
      const secondSelector = getSelector(second)
      const thirdSelector = getSelector(third)

      // Each should be unique
      expect(document.querySelectorAll(firstSelector)).toHaveLength(1)
      expect(document.querySelectorAll(firstSelector)[0]).toBe(first)

      expect(document.querySelectorAll(secondSelector)).toHaveLength(1)
      expect(document.querySelectorAll(secondSelector)[0]).toBe(second)

      expect(document.querySelectorAll(thirdSelector)).toHaveLength(1)
      expect(document.querySelectorAll(thirdSelector)[0]).toBe(third)
    })
  })

  describe('Priority 3: Tag paths with parent IDs (2-3x slower)', () => {
    test('should build tag path from parent ID', () => {
      container.innerHTML = `
        <div id="content">
          <article>
            <section>
              <p>Text</p>
            </section>
          </article>
        </div>
      `
      const p = container.querySelector('p')!
      const selector = getSelector(p)

      // Should use parent ID with tag path
      expect(selector).toMatch(/^#content/)
      expect(selector).toContain('p')

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(p)
    })

    test('should prefer descendant over child combinator for performance', () => {
      container.innerHTML = `
        <div id="parent">
          <span>Only child</span>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should use space (descendant) not > (child) for better performance
      expect(selector).toBe('#parent span')
      expect(selector).not.toContain('>')
    })
  })

  describe('Priority 4: Data attributes (30-40x slower)', () => {
    test('should use data-testid when no stable ID available', () => {
      container.innerHTML = `
        <div id="css-1a2b3c">
          <button data-testid="submit-button">Submit</button>
        </div>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)

      // Should use data-testid since parent ID is auto-generated
      expect(selector).toBe('[data-testid="submit-button"]')
    })

    test('should prefer unique ID over data-testid for performance', () => {
      container.innerHTML = `
        <button id="submit-btn" data-testid="submit-button">Submit</button>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)

      // Should prefer ID for performance
      expect(selector).toBe('#submit-btn')
    })

    test('should use data-test when data-testid not available', () => {
      container.innerHTML = `
        <input data-test="email-input" type="email">
      `
      const input = container.querySelector('input')!
      const selector = getSelector(input)
      expect(selector).toBe('[data-test="email-input"]')
    })

    test('should use data-cy for Cypress tests', () => {
      container.innerHTML = `
        <button data-cy="login-button">Login</button>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)
      expect(selector).toBe('[data-cy="login-button"]')
    })

    test('should ignore data-absmartly attributes', () => {
      container.innerHTML = `
        <div data-absmartly-experiment="test" id="content">
          <span>Text</span>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      expect(selector).not.toContain('data-absmartly')
      expect(selector).toBe('#content span')
    })
  })

  describe('Priority 5: Avoiding nth-child (100x+ slower)', () => {
    test('should not add nth-child for single children', () => {
      container.innerHTML = `
        <div id="parent">
          <div>
            <span>Only span here</span>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      expect(selector).not.toContain('nth-child')
      expect(selector).not.toContain('nth-of-type')
    })

    test('should use nth-of-type when absolutely necessary', () => {
      container.innerHTML = `
        <ul id="menu">
          <li>First</li>
          <li>Second</li>
          <li>Third</li>
        </ul>
      `
      const second = container.querySelectorAll('li')[1]
      const selector = getSelector(second)

      // Should use nth-of-type as last resort
      expect(selector).toContain('nth-of-type(2)')

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(second)
    })

    test('should handle multiple identical siblings efficiently', () => {
      container.innerHTML = `
        <div id="list">
          <span>Item 1</span>
          <span>Item 2</span>
          <span>Item 3</span>
        </div>
      `
      const items = container.querySelectorAll('span')
      const selectors = Array.from(items).map(item => getSelector(item))

      // Each should be unique
      selectors.forEach((sel, i) => {
        const matches = document.querySelectorAll(sel)
        expect(matches).toHaveLength(1)
        expect(matches[0]).toBe(items[i])

        // Should use nth-of-type for disambiguation
        if (i > 0) {
          expect(sel).toContain('nth-of-type')
        }
      })
    })
  })
})

describe('getSelector - Complex Real-World Cases', () => {
  let container: HTMLElement

  beforeEach(() => {
    document.body.innerHTML = ''
    container = document.createElement('div')
    document.body.appendChild(container)
  })

  afterEach(() => {
    document.body.innerHTML = ''
  })

  describe('E-commerce layouts (Amazon-like)', () => {
    test('should handle product cards with duplicate IDs', () => {
      container.innerHTML = `
        <div id="search-results">
          <div class="product-card">
            <div id="price-tag">$99.99</div>
            <div id="product-title">Product A</div>
          </div>
          <div class="product-card">
            <div id="price-tag">$199.99</div>
            <div id="product-title">Product B</div>
          </div>
        </div>
      `
      const firstPrice = container.querySelector('.product-card #price-tag')!
      const selector = getSelector(firstPrice)

      // Should create efficient selector with parent context
      expect(selector).toContain('#search-results')

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(firstPrice)
    })

    test('should handle deeply nested product listings', () => {
      container.innerHTML = `
        <div id="bhp-ab-gateway-desktop-atf-6">
          <div>
            <div>
              <div>
                <ul>
                  <li>
                    <a id="bnp-link">
                      <div id="bnp-recs-card-title">
                        <span>Product 1</span>
                      </div>
                    </a>
                  </li>
                  <li>
                    <a id="bnp-link">
                      <div id="bnp-recs-card-title">
                        <span>Product 2</span>
                      </div>
                    </a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      `
      const spans = container.querySelectorAll('span')
      const selectors = Array.from(spans).map(span => getSelector(span))

      selectors.forEach((sel, i) => {
        // Should use top-level ID for context
        expect(sel).toContain('#bhp-ab-gateway-desktop-atf-6')

        // Should be unique
        const matches = document.querySelectorAll(sel)
        expect(matches).toHaveLength(1)
        expect(matches[0]).toBe(spans[i])
      })
    })
  })

  describe('Auto-generated IDs and classes', () => {
    test('should ignore all types of auto-generated IDs', () => {
      container.innerHTML = `
        <div id="css-1a2b3c">
          <div id="framer-xyz123">
            <div id="sc-aBcDeF">
              <div id="123auto">
                <div class="MuiBox-root-456">
                  <span>Content</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should not use any auto-generated IDs
      expect(selector).not.toContain('css-')
      expect(selector).not.toContain('framer-')
      expect(selector).not.toContain('sc-')
      expect(selector).not.toContain('123auto')
      expect(selector).not.toContain('MuiBox')
    })

    test('should handle Tailwind and CSS module classes', () => {
      container.innerHTML = `
        <div class="flex-1 px-4 css-1a2b3c">
          <button class="btn-primary module_button__2eK9s">Click</button>
        </div>
      `
      const button = container.querySelector('button')!
      const selector = getSelector(button)

      // Should find a workable selector despite auto-generated classes
      expect(selector).toBeTruthy()

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(button)
    })
  })

  describe('Edge cases', () => {
    test('should handle empty element gracefully', () => {
      expect(getSelector(null as any)).toBe('')
      expect(getSelector(undefined as any)).toBe('')
    })

    test('should handle body element', () => {
      const selector = getSelector(document.body)
      expect(selector).toBe('body')

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(document.body)
    })

    test('should handle elements at max depth', () => {
      // Create deeply nested structure (more than 10 levels)
      let html = '<div id="root">'
      for (let i = 0; i < 15; i++) {
        html += '<div>'
      }
      html += '<span>Deep element</span>'
      for (let i = 0; i < 15; i++) {
        html += '</div>'
      }
      html += '</div>'

      container.innerHTML = html
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should create valid selector (may hit depth limit)
      expect(selector).toBeTruthy()

      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(span)
    })

    test('should handle special HTML5 semantic elements', () => {
      container.innerHTML = `
        <main>
          <article>
            <header>
              <h1>Title</h1>
            </header>
            <section>
              <p>Content</p>
            </section>
            <footer>
              <span>Footer text</span>
            </footer>
          </article>
        </main>
      `

      const h1 = container.querySelector('h1')!
      const p = container.querySelector('p')!
      const span = container.querySelector('span')!

      // Should handle semantic elements properly
      const h1Selector = getSelector(h1)
      expect(h1Selector).toContain('h1')

      const pSelector = getSelector(p)
      expect(pSelector).toContain('p')

      const spanSelector = getSelector(span)
      expect(spanSelector).toContain('span')

      // All should be unique
      expect(document.querySelectorAll(h1Selector)).toHaveLength(1)
      expect(document.querySelectorAll(pSelector)).toHaveLength(1)
      expect(document.querySelectorAll(spanSelector)).toHaveLength(1)
    })

    test('should handle SVG elements', () => {
      container.innerHTML = `
        <svg id="icon-svg">
          <g>
            <path d="M10 10"></path>
            <circle cx="50" cy="50" r="40"></circle>
          </g>
        </svg>
      `

      const path = container.querySelector('path')!
      const circle = container.querySelector('circle')!

      const pathSelector = getSelector(path)
      const circleSelector = getSelector(circle)

      // Should handle SVG elements
      expect(pathSelector).toContain('path')
      expect(circleSelector).toContain('circle')

      // Should be unique
      expect(document.querySelectorAll(pathSelector)).toHaveLength(1)
      expect(document.querySelectorAll(circleSelector)).toHaveLength(1)
    })
  })

  describe('Performance considerations', () => {
    test('should prefer descendant selector over child combinator', () => {
      container.innerHTML = `
        <div id="parent">
          <div>
            <div>
              <span>Text</span>
            </div>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should create a unique selector
      const matches = document.querySelectorAll(selector)
      expect(matches).toHaveLength(1)
      expect(matches[0]).toBe(span)

      // Should prefer simpler selectors
      expect(selector).toContain('#parent')
    })

    test('should minimize use of nth-child selectors', () => {
      container.innerHTML = `
        <div id="container">
          <div class="unique-class">
            <span>First</span>
          </div>
          <div>
            <span>Second</span>
          </div>
        </div>
      `
      const first = container.querySelectorAll('span')[0]
      const second = container.querySelectorAll('span')[1]

      const firstSelector = getSelector(first)
      const secondSelector = getSelector(second)

      // Should create unique selectors
      expect(document.querySelectorAll(firstSelector)).toHaveLength(1)
      expect(document.querySelectorAll(firstSelector)[0]).toBe(first)

      expect(document.querySelectorAll(secondSelector)).toHaveLength(1)
      expect(document.querySelectorAll(secondSelector)[0]).toBe(second)

      // At least one should avoid nth-child/nth-of-type
      const hasNthChild = firstSelector.includes('nth-') || secondSelector.includes('nth-')
      const bothHaveNth = firstSelector.includes('nth-') && secondSelector.includes('nth-')

      // Not both should have nth selectors if there's another way to distinguish
      expect(bothHaveNth).toBe(false)
    })

    test('should create shortest possible unique selector', () => {
      container.innerHTML = `
        <div id="app">
          <div id="unique-child">
            <span>Text</span>
          </div>
        </div>
      `
      const span = container.querySelector('span')!
      const selector = getSelector(span)

      // Should use nearest unique ID, not traverse to root
      expect(selector).toBe('#unique-child span')
      expect(selector).not.toContain('#app')
    })
  })
})
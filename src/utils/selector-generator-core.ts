/**
 * Core selector generation logic that can be used both in extension and injected scripts
 * This file contains the shared logic without module dependencies
 */

export const SELECTOR_GENERATOR_CODE = `
// Patterns that indicate auto-generated or framework-specific classes/IDs
const AUTO_GENERATED_PATTERNS = [
  /^framer-[a-zA-Z0-9]+$/,  // Framer classes like framer-F46SA
  /^[a-z]{1,3}-[a-f0-9]{6,}$/i,  // Hash-based classes
  /^css-[a-z0-9]+$/i,  // CSS modules
  /^sc-[a-zA-Z0-9]+$/,  // Styled-components
  /^[a-zA-Z0-9]{8,}$/,  // Long random strings (8+ chars)
  /^v-[a-f0-9]{8}$/,  // Vue scoped classes
  /^svelte-[a-z0-9]+$/,  // Svelte classes
  /^emotion-[0-9]+$/,  // Emotion CSS
  /^chakra-[a-z]+__[a-z]+-[a-z0-9]+$/,  // Chakra UI
  /^MuiBox-root-[0-9]+$/,  // Material-UI
  /^[a-zA-Z]+[0-9][a-zA-Z0-9]{15,}[_-]/,  // Normal prefix + digit + 15+ random chars + separator (catches CardInstance0nd0iSQcMZb94MDr_)
  /^[a-zA-Z]+[0-9]{3,}[a-zA-Z]+[0-9]{3,}/,  // Multiple groups of 3+ digits (like abc123def456)
  /_[a-f0-9]{8,}$/,  // Ending with underscored hex strings
];

// Helper function to check if string is auto-generated
function isAutoGenerated(str) {
  if (!str) return false;

  // IDs starting with numbers are likely auto-generated
  if (/^[0-9]/.test(str)) {
    return true;
  }

  return AUTO_GENERATED_PATTERNS.some(pattern => pattern.test(str));
}

// Generate a robust selector for an element with uniqueness check
function generateUniqueSelector(element) {
  if (!element) return '';

  // 1. Try ID if not auto-generated
  if (element.id && !isAutoGenerated(element.id)) {
    const idSelector = '#' + CSS.escape(element.id);
    const matches = document.querySelectorAll(idSelector);

    if (matches.length === 1) {
      return idSelector;
    }

    // ID should be unique, but some sites have duplicates
    console.log('[Selector] WARNING: Duplicate ID found:', element.id);
  }

  // 2. Try data attributes (testing-friendly)
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => {
      if (!attr.name.startsWith('data-')) return false;
      if (attr.name.includes('reactid') ||
          attr.name.includes('key') ||
          attr.name.includes('framer')) return false;
      if (!attr.value || isAutoGenerated(attr.value)) return false;
      return true;
    });

  for (const attr of dataAttrs) {
    const selector = \`[\${attr.name}="\${CSS.escape(attr.value)}"]\`;
    const matches = document.querySelectorAll(selector);
    if (matches.length === 1 && matches[0] === element) {
      return selector;
    }
  }

  // 3. Try meaningful classes
  if (element.className && typeof element.className === 'string') {
    const classes = element.className
      .trim()
      .split(/\\s+/)
      .filter(cls =>
        cls &&
        !cls.includes('absmartly') &&
        !cls.includes('hover') &&
        !cls.includes('active') &&
        !cls.includes('focus') &&
        !cls.includes('selected') &&
        !isAutoGenerated(cls) &&
        cls.length < 20
      );

    // Try single class selectors first
    for (const cls of classes) {
      const selector = '.' + CSS.escape(cls);
      const matches = document.querySelectorAll(selector);
      if (matches.length === 1 && matches[0] === element) {
        return selector;
      }
    }

    // Try combination of classes
    if (classes.length > 1) {
      const selector = classes.map(cls => '.' + CSS.escape(cls)).join('');
      const matches = document.querySelectorAll(selector);
      if (matches.length === 1 && matches[0] === element) {
        return selector;
      }
    }
  }

  // 4. Build contextual selector with parent
  let path = [];
  let current = element;
  let depth = 0;
  const maxDepth = 3;

  while (current && depth < maxDepth) {
    let segment = current.tagName.toLowerCase();

    // Add non-auto-generated classes
    if (current.className && typeof current.className === 'string') {
      const goodClasses = current.className
        .trim()
        .split(/\\s+/)
        .filter(cls =>
          cls &&
          !cls.includes('absmartly') &&
          !isAutoGenerated(cls) &&
          cls.length < 20
        )
        .slice(0, 2); // Max 2 classes per element

      if (goodClasses.length > 0) {
        segment += goodClasses.map(cls => '.' + CSS.escape(cls)).join('');
      }
    }

    // Check uniqueness at this level
    const selector = [...path, segment].join(' > ');
    const matches = document.querySelectorAll(selector);

    if (matches.length === 1 && matches[0] === element) {
      return selector;
    }

    // Add nth-of-type if needed
    if (matches.length > 1) {
      const siblings = Array.from(current.parentElement?.children || [])
        .filter(child => child.tagName === current.tagName);
      const index = siblings.indexOf(current) + 1;

      if (index > 0) {
        segment += \`:nth-of-type(\${index})\`;
        const uniqueSelector = [...path, segment].join(' > ');
        const uniqueMatches = document.querySelectorAll(uniqueSelector);

        if (uniqueMatches.length === 1 && uniqueMatches[0] === element) {
          return uniqueSelector;
        }
      }
    }

    path.unshift(segment);
    current = current.parentElement;
    depth++;

    // Stop at body or html
    if (current && (current.tagName === 'BODY' || current.tagName === 'HTML')) {
      break;
    }
  }

  // Return the most specific selector we could build
  return path.join(' > ');
}
`;
/**
 * Selector generator for visual editor
 * This is the selector generation logic used by the visual editor in background.ts
 */

/**
 * Escape CSS selector special characters
 */
function escapeSelector(str: string): string {
  // Use CSS.escape if available, otherwise do basic escaping
  if (typeof CSS !== 'undefined' && CSS.escape) {
    return CSS.escape(str)
  }
  // Basic escaping for common special characters
  return str.replace(/([:#.\[\](),>+~"'=\s])/g, '\\$1')
}

/**
 * Check if a string looks auto-generated
 */
export function isAutoGenerated(str: string): boolean {
  if (!str) return false

  // CRITICAL: Skip IDs/classes added by ABSmartly itself
  if (str.includes('absmartly') || str.includes('ABSmartly')) {
    return true
  }

  // IDs starting with numbers are likely auto-generated
  if (/^[0-9]/.test(str)) {
    return true
  }

  // Check for framework-specific patterns
  const patterns = [
    /^framer-[a-zA-Z0-9]+$/,  // Framer classes
    /^css-[a-z0-9]+$/i,  // CSS modules
    /^sc-[a-zA-Z0-9]+$/,  // Styled-components
    /^v-[a-f0-9]{8}$/,  // Vue scoped classes
    /^svelte-[a-z0-9]+$/,  // Svelte classes
    /^emotion-[0-9]+$/,  // Emotion CSS
    /^chakra-/,  // Chakra UI
    /^MuiBox-root/,  // Material-UI
    /^[a-f0-9]{8,}$/i,  // Hex strings
    /_[a-f0-9]{6,}$/i  // Ending with hex strings
  ]

  if (patterns.some(pattern => pattern.test(str))) {
    return true
  }

  // Look for random character sequences in segments
  const segments = str.split(/[-_]/)
  for (const segment of segments) {
    if (segment.length < 6) continue

    // Check if segment looks like a normal word
    const looksNormal = /^[A-Z][a-z]+$/.test(segment) || // PascalCase word
                       /^[a-z]+$/.test(segment) ||        // all lowercase
                       /^[A-Z]+$/.test(segment) ||        // all uppercase
                       /^[a-z]+[0-9]{1,2}$/.test(segment) // word with 1-2 digits

    if (!looksNormal) {
      // Check for random patterns: mixed case/numbers without clear pattern
      if (/[0-9][a-zA-Z]{2,}[0-9]/.test(segment) ||  // number-letters-number
          /[a-z][A-Z]{2,}[a-z]/.test(segment) ||      // lowercase-UPPER-lowercase
          /[A-Z][a-z][0-9][a-zA-Z]{3,}/.test(segment)) { // Mixed pattern
        return true
      }
    }
  }

  return false
}

/**
 * Generate a unique CSS selector for an element
 */
export function getSelector(element: Element): string {
  if (!element) return ''

  // First, check if element has a unique, stable ID
  if (element.id && !isAutoGenerated(element.id)) {
    // Escape special characters in ID
    const escapedId = escapeSelector(element.id)
    const idSelector = '#' + escapedId
    try {
      const idMatches = document.querySelectorAll(idSelector)
      if (idMatches.length === 1) {
        console.log('[ABSmartly] Element has unique ID:', element.id)
        return idSelector
      }
    } catch (e) {
      console.error('[ABSmartly] Invalid ID selector:', e)
    }
  }

  // If no unique ID, check for data attributes (but skip ABSmartly-added ones)
  // These are good for testing and won't change for styling reasons
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => {
      return attr.name.startsWith('data-') &&
             !attr.name.startsWith('data-absmartly') &&
             attr.value &&
             attr.value.length < 50 &&
             !attr.value.includes('"') &&
             !attr.value.includes("'")
    })

  // Prefer certain data attributes that are commonly used for testing
  const preferredDataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-id', 'data-name']
  const preferredAttr = dataAttrs.find(attr => preferredDataAttrs.includes(attr.name))

  if (preferredAttr) {
    const dataSelector = '[' + preferredAttr.name + '="' + preferredAttr.value + '"]'
    try {
      const matches = document.querySelectorAll(dataSelector)
      if (matches.length === 1 && matches[0] === element) {
        console.log('[ABSmartly] Using data attribute selector:', dataSelector)
        return dataSelector
      }
    } catch (e) {
      console.error('[ABSmartly] Invalid data selector:', e)
    }
  }

  // Build selector using parent chain if no good ID or class
  // First, collect the element path from target to root
  const pathElements: Element[] = []
  let current: Element | null = element
  const maxDepth = 10

  while (current && current !== document.body && current !== document.documentElement && pathElements.length < maxDepth) {
    pathElements.push(current)
    current = current.parentElement
  }

  // Look for the closest element with an ID (even if duplicate) and build minimal path
  for (let i = 0; i < pathElements.length; i++) {
    const elem = pathElements[i]

    if (elem.id && !isAutoGenerated(elem.id)) {
      // Found an ID, try to build selector from here
      // Escape special characters in ID
      const escapedId = escapeSelector(elem.id)
      let selector = '#' + escapedId

      // Add minimal path from this ID to target
      if (i > 0) {
        // Check if we need intermediate elements
        let minimalPath: string[] = []

        // First try direct child selector
        if (i === 1) {
          // Direct child
          minimalPath = [pathElements[0].tagName.toLowerCase()]
        } else {
          // Try with just the target element tag
          minimalPath = [pathElements[0].tagName.toLowerCase()]
          const testSel = selector + ' ' + minimalPath.join(' > ')
          const testMatches = document.querySelectorAll(testSel)

          if (testMatches.length !== 1 || testMatches[0] !== element) {
            // Need more specificity, add immediate parent
            minimalPath = []
            for (let j = i - 1; j >= 0; j--) {
              const pathElem = pathElements[j]
              if (pathElem.id && !isAutoGenerated(pathElem.id)) {
                minimalPath.push('#' + pathElem.id)
                break
              } else {
                minimalPath.push(pathElem.tagName.toLowerCase())
              }
            }
          }
        }

        selector = selector + ' > ' + minimalPath.join(' > ')
      }

      // Test if this selector is unique
      const matches = document.querySelectorAll(selector)
      if (matches.length === 1 && matches[0] === element) {
        console.log('[ABSmartly] Found minimal selector with ID:', selector)
        return selector
      }

      // If not unique, we need parent context
      // Find the minimal parent that makes it unique
      for (let parentIdx = i + 1; parentIdx < pathElements.length; parentIdx++) {
        const parent = pathElements[parentIdx]

        if (parent.id && !isAutoGenerated(parent.id)) {
          const parentSelector = '#' + parent.id
          const fullSelector = parentSelector + ' ' + selector
          const fullMatches = document.querySelectorAll(fullSelector)

          if (fullMatches.length === 1 && fullMatches[0] === element) {
            console.log('[ABSmartly] Made unique with parent context:', fullSelector)
            return fullSelector
          }
        }
      }
    }
  }

  // Try with minimal tag path, but always include parent IDs for context
  for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
    const basePath: string[] = []
    let foundId = false

    for (let i = startDepth - 1; i >= 0; i--) {
      const elem = pathElements[i]

      // If we find a parent with ID, use it as anchor
      if (elem.id && !isAutoGenerated(elem.id)) {
        basePath.unshift('#' + elem.id)
        foundId = true
        // Add remaining path to target
        for (let j = i - 1; j >= 0; j--) {
          basePath.push(pathElements[j].tagName.toLowerCase())
        }
        break
      } else {
        basePath.unshift(elem.tagName.toLowerCase())
      }
    }

    const selector = basePath.join(' > ')
    const matches = document.querySelectorAll(selector)

    if (matches.length === 1 && matches[0] === element) {
      // Don't accept single tag selectors - too brittle!
      if (!selector.includes('#') && !selector.includes('>') && !selector.includes('[')) {
        console.log('[ABSmartly] Single tag selector too brittle, continuing search:', selector)
        continue
      }
      console.log('[ABSmartly] Found unique selector with context:', selector)
      return selector
    }
  }

  // If no parent IDs and simple tag paths don't work, try just the tag if it's unique
  const tagName = element.tagName.toLowerCase()
  const tagMatches = document.querySelectorAll(tagName)
  if (tagMatches.length === 1 && tagMatches[0] === element) {
    // For common structural tags, still try to add some context
    if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'main', 'nav', 'article', 'section', 'aside'].includes(tagName)) {
      // Try to find a parent for context
      if (element.parentElement && element.parentElement !== document.body && element.parentElement !== document.documentElement) {
        const parentTag = element.parentElement.tagName.toLowerCase()
        const parentSelector = parentTag + ' > ' + tagName
        const parentMatches = document.querySelectorAll(parentSelector)
        if (parentMatches.length === 1 && parentMatches[0] === element) {
          console.log('[ABSmartly] Added parent context to structural tag:', parentSelector)
          return parentSelector
        }
      }
    }
    // Only return bare tag for very specific cases
    if (tagName === 'body' || tagName === 'html') {
      return tagName
    }
  }

  // If simple paths don't work, we need to add specificity
  console.log('[ABSmartly] Simple paths not unique. Adding specificity...')

  // Try using IDs even if duplicate, adding parent context as needed
  for (let i = 0; i < pathElements.length; i++) {
    const elem = pathElements[i]

    if (elem.id && !isAutoGenerated(elem.id)) {
      // Check if this ID is unique
      const idMatches = document.querySelectorAll('#' + elem.id)

      if (idMatches.length === 1 && i === 0) {
        // Target element has unique ID, use it directly
        return '#' + elem.id
      }

      // ID exists but may be duplicate - build selector
      let selector = '#' + elem.id

      // If this is not the target element, add path to target
      if (i > 0) {
        const pathToTarget: string[] = []
        for (let j = i - 1; j >= 0; j--) {
          const child = pathElements[j]
          let childPart = child.tagName.toLowerCase()

          // Only add nth-child if needed
          if (child.parentElement) {
            const siblings = Array.from(child.parentElement.children)
            if (siblings.length > 1) {
              const idx = siblings.indexOf(child) + 1
              childPart += ':nth-child(' + idx + ')'
            }
          }
          pathToTarget.push(childPart)
        }
        selector = selector + ' > ' + pathToTarget.join(' > ')
      }

      // Test if selector is unique
      const matches = document.querySelectorAll(selector)
      if (matches.length === 1 && matches[0] === element) {
        console.log('[ABSmartly] Found unique selector:', selector)
        return selector
      }

      // Selector not unique, we need parent context
      // For duplicate IDs, we need to disambiguate the parent container
      if (idMatches.length > 1 || matches.length > 1) {
        // Find the container that holds this duplicate ID
        const idElement = elem
        const idParent = idElement.parentElement

        if (idParent) {
          // Build selector: find unique ancestor + path to parent + parent with nth-child + our ID
          for (let a = i + 2; a < pathElements.length; a++) {
            const ancestor = pathElements[a]
            if (ancestor.id && !isAutoGenerated(ancestor.id)) {
              // Build path from ancestor to the parent of our ID element
              let ancestorSelector = '#' + ancestor.id
              const pathToParent: string[] = []

              for (let p = a - 1; p > i; p--) {
                const pathElem = pathElements[p]
                let part = pathElem.tagName.toLowerCase()

                // Add class if it helps (and is not auto-generated)
                if (pathElem.className && !isAutoGenerated(pathElem.className.split(' ')[0])) {
                  part += '.' + pathElem.className.split(' ')[0]
                }
                // Add nth-child if needed
                else if (pathElem.parentElement) {
                  const sibs = Array.from(pathElem.parentElement.children)
                  if (sibs.length > 1) {
                    const idx = sibs.indexOf(pathElem) + 1
                    part += ':nth-child(' + idx + ')'
                  }
                }
                pathToParent.push(part)
              }

              // Complete selector
              let completeSelector = ancestorSelector
              if (pathToParent.length > 0) {
                completeSelector += ' > ' + pathToParent.join(' > ')
              }
              completeSelector += ' > ' + selector

              const finalMatches = document.querySelectorAll(completeSelector)
              if (finalMatches.length === 1 && finalMatches[0] === element) {
                console.log('[ABSmartly] Disambiguated with ancestor:', completeSelector)
                return completeSelector
              }
            }
          }
        }
      }
    }
  }

  // Try adding nth-child only where necessary
  for (let targetIndex = 0; targetIndex < pathElements.length; targetIndex++) {
    const targetElem = pathElements[targetIndex]

    // Try minimal selector with nth-child at this level
    for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
      const specificPath: string[] = []
      let foundUniqueId = false

      for (let i = startDepth - 1; i >= 0; i--) {
        const elem = pathElements[i]

        if (elem.id && !isAutoGenerated(elem.id)) {
          const idMatches = document.querySelectorAll('#' + elem.id)
          if (idMatches.length === 1) {
            // Unique ID found, use as anchor
            specificPath.length = 0
            specificPath.push('#' + elem.id)
            foundUniqueId = true
            // Add rest of path
            for (let j = i - 1; j >= 0; j--) {
              if (j === targetIndex && pathElements[j].parentElement) {
                // Only add nth-child at target if needed
                const siblings = Array.from(pathElements[j].parentElement.children)
                if (siblings.length > 1) {
                  const childIndex = siblings.indexOf(pathElements[j]) + 1
                  specificPath.push(pathElements[j].tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
                } else {
                  specificPath.push(pathElements[j].tagName.toLowerCase())
                }
              } else {
                specificPath.push(pathElements[j].tagName.toLowerCase())
              }
            }
            break
          } else {
            // Duplicate ID - still use it!
            if (i === targetIndex && elem.parentElement) {
              // Only add nth-child if there are multiple siblings
              const siblings = Array.from(elem.parentElement.children)
              if (siblings.length > 1) {
                const childIndex = siblings.indexOf(elem) + 1
                specificPath.unshift('#' + elem.id + ':nth-child(' + childIndex + ')')
              } else {
                specificPath.unshift('#' + elem.id)
              }
            } else {
              specificPath.unshift('#' + elem.id)
            }
          }
        } else if (i === targetIndex && elem.parentElement) {
          // Add nth-child at target level only if there are multiple siblings
          const siblings = Array.from(elem.parentElement.children)
          if (siblings.length > 1) {
            const childIndex = siblings.indexOf(elem) + 1
            specificPath.unshift(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
          } else {
            specificPath.unshift(elem.tagName.toLowerCase())
          }
        } else {
          specificPath.unshift(elem.tagName.toLowerCase())
        }
      }

      const testSelector = specificPath.join(' > ')
      const testMatches = document.querySelectorAll(testSelector)

      if (testMatches.length === 1 && testMatches[0] === element) {
        console.log('[ABSmartly] Found minimal unique selector with nth-child at', targetElem.tagName, ':', testSelector)
        return testSelector
      }

      // If we have a unique ID anchor, no need to try longer paths
      if (foundUniqueId) break
    }
  }

  // Last resort: use nth-child but still try to keep it minimal
  console.log('[ABSmartly] Using fallback with nth-child')

  // Try building minimal selector with nth-child, starting from shortest path
  for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
    const fallbackPath: string[] = []
    let foundUniqueId = false

    for (let i = startDepth - 1; i >= 0; i--) {
      const elem = pathElements[i]

      if (elem.id && !isAutoGenerated(elem.id)) {
        const idMatches = document.querySelectorAll('#' + elem.id)
        if (idMatches.length === 1) {
          fallbackPath.length = 0
          fallbackPath.push('#' + elem.id)
          foundUniqueId = true
          // Add rest of path, only using nth-child when necessary
          for (let j = i - 1; j >= 0; j--) {
            const e = pathElements[j]
            let selector = e.tagName.toLowerCase()

            // Only add nth-child if there are multiple siblings
            if (e.parentElement) {
              const siblings = Array.from(e.parentElement.children)
              if (siblings.length > 1) {
                const idx = siblings.indexOf(e) + 1
                selector += ':nth-child(' + idx + ')'
              }
            }

            fallbackPath.push(selector)
          }
          break
        } else {
          // Duplicate ID, use nth-child only if needed
          let selector = elem.tagName.toLowerCase()
          if (elem.parentElement) {
            const siblings = Array.from(elem.parentElement.children)
            if (siblings.length > 1) {
              const idx = siblings.indexOf(elem) + 1
              selector += ':nth-child(' + idx + ')'
            }
          }
          fallbackPath.unshift(selector)
        }
      } else {
        let selector = elem.tagName.toLowerCase()
        // Only add nth-child if there are multiple siblings
        if (elem.parentElement) {
          const siblings = Array.from(elem.parentElement.children)
          if (siblings.length > 1) {
            const idx = siblings.indexOf(elem) + 1
            selector += ':nth-child(' + idx + ')'
          }
        }
        fallbackPath.unshift(selector)
      }
    }

    const testSelector = fallbackPath.join(' > ')
    const testMatches = document.querySelectorAll(testSelector)

    if (testMatches.length === 1 && testMatches[0] === element) {
      console.log('[ABSmartly] Found minimal fallback selector:', testSelector)
      return testSelector
    }

    if (foundUniqueId) break
  }

  // If still not unique (shouldn't happen), return the full path
  const selector = pathElements.map((elem, i) => {
    let sel = elem.tagName.toLowerCase()
    if (elem.parentElement && i > 0) {
      const siblings = Array.from(elem.parentElement.children)
      if (siblings.length > 1) {
        const idx = siblings.indexOf(elem) + 1
        sel += ':nth-child(' + idx + ')'
      }
    }
    return sel
  }).reverse().join(' > ')

  // Handle edge case of empty selector
  if (!selector) {
    return element.tagName.toLowerCase()
  }

  console.log('[ABSmartly] Final selector:', selector, 'Matches:', document.querySelectorAll(selector).length)
  return selector
}
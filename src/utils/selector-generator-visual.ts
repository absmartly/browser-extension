/**
 * Selector generator for visual editor
 * This is the selector generation logic used by the visual editor in background.ts
 */

/**
 * Escape CSS selector special characters
 */
function escapeSelector(str: string): string {
  // Use CSS.escape if available, otherwise do basic escaping
  if (typeof CSS !== 'undefined' && CSS.escape) {
    return CSS.escape(str)
  }
  // Basic escaping for common special characters
  return str.replace(/([:#.\[\](),>+~"'=\s])/g, '\\$1')
}

/**
 * Check if a string looks auto-generated
 */
export function isAutoGenerated(str: string): boolean {
  if (!str) return false

  // CRITICAL: Skip IDs/classes added by ABSmartly itself
  if (str.includes('absmartly') || str.includes('ABSmartly')) {
    return true
  }

  // IDs starting with numbers are likely auto-generated
  if (/^[0-9]/.test(str)) {
    return true
  }

  // Check for framework-specific patterns
  const patterns = [
    /^framer-[a-zA-Z0-9]+$/,  // Framer classes
    /^css-[a-z0-9]+$/i,  // CSS modules
    /^sc-[a-zA-Z0-9]+$/,  // Styled-components
    /^v-[a-f0-9]{8}$/,  // Vue scoped classes
    /^svelte-[a-z0-9]+$/,  // Svelte classes
    /^emotion-[0-9]+$/,  // Emotion CSS
    /^chakra-/,  // Chakra UI
    /^MuiBox-root/,  // Material-UI
    /^[a-f0-9]{8,}$/i,  // Hex strings
    /_[a-f0-9]{6,}$/i  // Ending with hex strings
  ]

  if (patterns.some(pattern => pattern.test(str))) {
    return true
  }

  // Look for random character sequences in segments
  const segments = str.split(/[-_]/)
  for (const segment of segments) {
    // Skip very short segments
    if (segment.length < 3) continue

    // Check if segment looks like a normal word
    const looksNormal = /^[A-Z][a-z]+$/.test(segment) || // PascalCase word
                       /^[a-z]+$/.test(segment) ||        // all lowercase
                       /^[A-Z]+$/.test(segment) ||        // all uppercase
                       /^[a-z]+[0-9]{1,2}$/.test(segment) // word with 1-2 digits

    if (!looksNormal) {
      // For shorter segments (3-5 chars), check for mixed alphanumeric
      if (segment.length <= 5) {
        // Random mix of letters and numbers (e.g., "6h6XQ", "a1b2")
        if (/\d/.test(segment) && /[a-zA-Z]/.test(segment)) {
          // Has both numbers and letters mixed
          if (!/^[a-z]+\d{1,2}$/.test(segment) && // Not like "test1"
              !/^\d{1,2}[a-z]+$/.test(segment)) {   // Not like "1st"
            return true
          }
        }
      } else {
        // For longer segments, check for random patterns
        if (/[0-9][a-zA-Z]{2,}[0-9]/.test(segment) ||  // number-letters-number
            /[a-z][A-Z]{2,}[a-z]/.test(segment) ||      // lowercase-UPPER-lowercase
            /[A-Z][a-z][0-9][a-zA-Z]{3,}/.test(segment)) { // Mixed pattern
          return true
        }
      }
    }
  }

  return false
}

/**
 * Generate a unique CSS selector for an element
 * Priority based on performance testing:
 * 1. Unique IDs (fastest - baseline)
 * 2. Duplicate IDs with simple parent (1.08x slower)
 * 3. Tag paths with parent IDs (2-3x slower)
 * 4. Data attributes (30-40x slower)
 * 5. Selectors with :nth-child() (100x+ slower - avoid when possible)
 */
export function getSelector(element: Element): string {
  if (!element) return ''

  // PRIORITY 1: Check if element has a unique, stable ID (fastest)
  if (element.id && !isAutoGenerated(element.id)) {
    const escapedId = escapeSelector(element.id)
    const idSelector = '#' + escapedId
    try {
      const idMatches = document.querySelectorAll(idSelector)
      if (idMatches.length === 1) {
        console.log('[ABSmartly] Using unique ID (fastest):', element.id)
        return idSelector
      }
    } catch (e) {
      console.error('[ABSmartly] Invalid ID selector:', e)
    }
  }

  // Collect the element path from target to root for building selectors
  const pathElements: Element[] = []
  let current: Element | null = element
  const maxDepth = 10

  while (current && current !== document.body && current !== document.documentElement && pathElements.length < maxDepth) {
    pathElements.push(current)
    current = current.parentElement
  }

  // PRIORITY 2: Try duplicate IDs with simple parent context (1.08x slower than unique ID)
  if (element.id && !isAutoGenerated(element.id)) {
    // Element has duplicate ID, find parent with ID to make it unique
    for (let i = 1; i < pathElements.length; i++) {
      const parent = pathElements[i]
      if (parent.id && !isAutoGenerated(parent.id)) {
        const parentId = escapeSelector(parent.id)
        const elemId = escapeSelector(element.id)
        // Use simple descendant selector (avoid > and nth-child for performance)
        const selector = `#${parentId} #${elemId}`

        try {
          const matches = document.querySelectorAll(selector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Using duplicate ID with parent context (fast):', selector)
            return selector
          }
        } catch (e) {
          console.error('[ABSmartly] Invalid selector:', e)
        }
      }
    }
  }

  // PRIORITY 3: Try building selector with parent ID and tag path (2-3x slower)
  for (let i = 1; i < pathElements.length; i++) {
    const parent = pathElements[i]
    if (parent.id && !isAutoGenerated(parent.id)) {
      // Build simple tag path from parent to element (avoid nth-child)
      const parentId = escapeSelector(parent.id)
      const tagPath: string[] = []

      for (let j = i - 1; j >= 0; j--) {
        const currentElem = pathElements[j]
        let pathPart = currentElem.tagName.toLowerCase()

        // Include unique classes in the path to avoid nth-child
        if (currentElem.classList && currentElem.classList.length > 0) {
          const uniqueClass = Array.from(currentElem.classList)
            .find(cls => {
              if (isAutoGenerated(cls)) return false
              const classMatches = document.querySelectorAll('.' + escapeSelector(cls))
              return classMatches.length === 1
            })

          if (uniqueClass) {
            pathPart += '.' + escapeSelector(uniqueClass)
          }
        }

        tagPath.push(pathPart)
      }

      // Try with descendant selector first (fastest)
      let selector = `#${parentId} ${tagPath.join(' > ')}`

      try {
        const matches = document.querySelectorAll(selector)
        if (matches.length === 1 && matches[0] === element) {
          console.log('[ABSmartly] Using parent ID with tag path (moderately fast):', selector)
          return selector
        }

        // If not unique with simple path, try adding element's duplicate ID if it has one
        if (element.id && !isAutoGenerated(element.id) && matches.length > 1) {
          const elemId = escapeSelector(element.id)
          selector = `#${parentId} #${elemId}`
          const idMatches = document.querySelectorAll(selector)
          if (idMatches.length === 1 && idMatches[0] === element) {
            console.log('[ABSmartly] Using parent ID with duplicate child ID:', selector)
            return selector
          }
        }
      } catch (e) {
        console.error('[ABSmartly] Invalid selector:', e)
      }
    }
  }

  // PRIORITY 3.5: Try unique class names to avoid nth-child (similar performance to tag paths)
  // Check if element has unique, non-auto-generated classes
  if (element.classList && element.classList.length > 0) {
    const classes = Array.from(element.classList).filter(cls => !isAutoGenerated(cls))

    for (const className of classes) {
      const classSelector = '.' + escapeSelector(className)

      try {
        // First try the class alone
        const matches = document.querySelectorAll(classSelector)
        if (matches.length === 1 && matches[0] === element) {
          console.log('[ABSmartly] Using unique class selector:', classSelector)
          return classSelector
        }

        // If not unique, try with parent context
        for (let i = 1; i < pathElements.length; i++) {
          const parent = pathElements[i]
          if (parent.id && !isAutoGenerated(parent.id)) {
            const parentId = escapeSelector(parent.id)
            const parentClassSelector = `#${parentId} ${classSelector}`
            const parentMatches = document.querySelectorAll(parentClassSelector)
            if (parentMatches.length === 1 && parentMatches[0] === element) {
              console.log('[ABSmartly] Using class with parent ID:', parentClassSelector)
              return parentClassSelector
            }

            // Try with tag name for more specificity
            const tagClassSelector = `#${parentId} ${element.tagName.toLowerCase()}${classSelector}`
            const tagMatches = document.querySelectorAll(tagClassSelector)
            if (tagMatches.length === 1 && tagMatches[0] === element) {
              console.log('[ABSmartly] Using tag+class with parent ID:', tagClassSelector)
              return tagClassSelector
            }
          }
        }
      } catch (e) {
        console.error('[ABSmartly] Invalid class selector:', e)
      }
    }
  }

  // PRIORITY 4: Check for data attributes (30-40x slower, but stable)
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => {
      return attr.name.startsWith('data-') &&
             !attr.name.startsWith('data-absmartly') &&
             attr.value &&
             attr.value.length < 50 &&
             !attr.value.includes('"') &&
             !attr.value.includes("'")
    })

  const preferredDataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-id', 'data-name']
  const preferredAttr = dataAttrs.find(attr => preferredDataAttrs.includes(attr.name))

  if (preferredAttr) {
    const dataSelector = '[' + preferredAttr.name + '="' + preferredAttr.value + '"]'
    try {
      const matches = document.querySelectorAll(dataSelector)
      if (matches.length === 1 && matches[0] === element) {
        console.log('[ABSmartly] Using data attribute (slower but stable):', dataSelector)
        return dataSelector
      }

      // Try with parent ID for better performance
      for (let i = 1; i < pathElements.length; i++) {
        const parent = pathElements[i]
        if (parent.id && !isAutoGenerated(parent.id)) {
          const parentId = escapeSelector(parent.id)
          const parentDataSelector = `#${parentId} ${dataSelector}`
          const parentMatches = document.querySelectorAll(parentDataSelector)
          if (parentMatches.length === 1 && parentMatches[0] === element) {
            console.log('[ABSmartly] Using data attribute with parent ID:', parentDataSelector)
            return parentDataSelector
          }
        }
      }
    } catch (e) {
      console.error('[ABSmartly] Invalid data selector:', e)
    }
  }

  // Try with minimal tag path, but always include parent IDs or unique classes for context
  for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
    const basePath: string[] = []
    let foundId = false

    for (let i = startDepth - 1; i >= 0; i--) {
      const elem = pathElements[i]

      // If we find a parent with ID, use it as anchor
      if (elem.id && !isAutoGenerated(elem.id)) {
        basePath.unshift('#' + escapeSelector(elem.id))
        foundId = true
        // Add remaining path to target
        for (let j = i - 1; j >= 0; j--) {
          const childElem = pathElements[j]
          let pathPart = childElem.tagName.toLowerCase()

          // Add unique class if available to help distinguish
          if (childElem.classList && childElem.classList.length > 0) {
            const uniqueClass = Array.from(childElem.classList)
              .find(cls => {
                if (isAutoGenerated(cls)) return false
                // Only use if it helps distinguish among siblings
                if (childElem.parentElement) {
                  const siblings = Array.from(childElem.parentElement.children)
                    .filter(s => s.tagName === childElem.tagName && s !== childElem)
                  if (siblings.some(s => s.classList.contains(cls))) {
                    return false  // Not unique among siblings
                  }
                }
                return true
              })

            if (uniqueClass) {
              pathPart += '.' + escapeSelector(uniqueClass)
            }
          }

          basePath.push(pathPart)
        }
        break
      } else {
        let pathPart = elem.tagName.toLowerCase()

        // Try to add a unique class if available
        if (elem.classList && elem.classList.length > 0) {
          const uniqueClass = Array.from(elem.classList)
            .find(cls => {
              if (isAutoGenerated(cls)) return false
              const classMatches = document.querySelectorAll('.' + escapeSelector(cls))
              return classMatches.length === 1
            })

          if (uniqueClass) {
            pathPart += '.' + escapeSelector(uniqueClass)
          }
        }

        basePath.unshift(pathPart)
      }
    }

    const selector = basePath.join(' > ')
    const matches = document.querySelectorAll(selector)

    if (matches.length === 1 && matches[0] === element) {
      // Don't accept single tag selectors - too brittle!
      if (!selector.includes('#') && !selector.includes('>') && !selector.includes('[') && !selector.includes('.')) {
        console.log('[ABSmartly] Single tag selector too brittle, continuing search:', selector)
        continue
      }
      console.log('[ABSmartly] Found unique selector with context:', selector)
      return selector
    }
  }

  // If no parent IDs and simple tag paths don't work, try just the tag if it's unique
  const tagName = element.tagName.toLowerCase()
  const tagMatches = document.querySelectorAll(tagName)
  if (tagMatches.length === 1 && tagMatches[0] === element) {
    // For common structural tags, still try to add some context
    if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'main', 'nav', 'article', 'section', 'aside'].includes(tagName)) {
      // Try to find a parent for context
      if (element.parentElement && element.parentElement !== document.body && element.parentElement !== document.documentElement) {
        const parentTag = element.parentElement.tagName.toLowerCase()
        const parentSelector = parentTag + ' > ' + tagName
        const parentMatches = document.querySelectorAll(parentSelector)
        if (parentMatches.length === 1 && parentMatches[0] === element) {
          console.log('[ABSmartly] Added parent context to structural tag:', parentSelector)
          return parentSelector
        }
      }
    }
    // Only return bare tag for very specific cases
    if (tagName === 'body' || tagName === 'html') {
      return tagName
    }
  }

  // If simple paths don't work, we need more specificity
  console.log('[ABSmartly] Simple selectors not unique. Adding specificity...')

  // PRIORITY 5: Last resort - use nth-child (100x+ slower, but guarantees uniqueness)
  // Only use when absolutely necessary as performance is very poor
  console.log('[ABSmartly] WARNING: Using nth-child selectors (poor performance)...')

  // Try to minimize nth-child usage by finding closest parent with ID
  for (let parentIdx = 0; parentIdx < pathElements.length; parentIdx++) {
    const parent = pathElements[parentIdx]

    if (parent.id && !isAutoGenerated(parent.id)) {
      const parentId = escapeSelector(parent.id)
      const path: string[] = [`#${parentId}`]

      // Build path from parent to element, using nth-child only where necessary
      for (let i = parentIdx - 1; i >= 0; i--) {
        const elem = pathElements[i]
        let selector = elem.tagName.toLowerCase()

        // Only add nth-child if there are multiple siblings of same tag
        if (elem.parentElement) {
          const sameTags = Array.from(elem.parentElement.children)
            .filter(child => child.tagName === elem.tagName)

          if (sameTags.length > 1) {
            const idx = sameTags.indexOf(elem) + 1
            selector += ':nth-of-type(' + idx + ')'
          }
        }

        path.push(selector)
      }

      const fullSelector = path.join(' > ')

      try {
        const matches = document.querySelectorAll(fullSelector)
        if (matches.length === 1 && matches[0] === element) {
          console.log('[ABSmartly] Using nth-of-type selector (slow but unique):', fullSelector)
          return fullSelector
        }
      } catch (e) {
        console.error('[ABSmartly] Invalid selector:', e)
      }
    }
  }

  // Last resort: use nth-child but still try to keep it minimal
  console.log('[ABSmartly] Using fallback with nth-child')

  // Try building minimal selector with nth-child, starting from shortest path
  for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
    const fallbackPath: string[] = []
    let foundUniqueId = false

    for (let i = startDepth - 1; i >= 0; i--) {
      const elem = pathElements[i]

      if (elem.id && !isAutoGenerated(elem.id)) {
        const idMatches = document.querySelectorAll('#' + elem.id)
        if (idMatches.length === 1) {
          fallbackPath.length = 0
          fallbackPath.push('#' + elem.id)
          foundUniqueId = true
          // Add rest of path, only using nth-child when necessary
          for (let j = i - 1; j >= 0; j--) {
            const e = pathElements[j]
            let selector = e.tagName.toLowerCase()

            // Only add nth-child if there are multiple siblings
            if (e.parentElement) {
              const siblings = Array.from(e.parentElement.children)
              if (siblings.length > 1) {
                const idx = siblings.indexOf(e) + 1
                selector += ':nth-child(' + idx + ')'
              }
            }

            fallbackPath.push(selector)
          }
          break
        } else {
          // Duplicate ID, use nth-child only if needed
          let selector = elem.tagName.toLowerCase()
          if (elem.parentElement) {
            const siblings = Array.from(elem.parentElement.children)
            if (siblings.length > 1) {
              const idx = siblings.indexOf(elem) + 1
              selector += ':nth-child(' + idx + ')'
            }
          }
          fallbackPath.unshift(selector)
        }
      } else {
        let selector = elem.tagName.toLowerCase()
        // Only add nth-child if there are multiple siblings
        if (elem.parentElement) {
          const siblings = Array.from(elem.parentElement.children)
          if (siblings.length > 1) {
            const idx = siblings.indexOf(elem) + 1
            selector += ':nth-child(' + idx + ')'
          }
        }
        fallbackPath.unshift(selector)
      }
    }

    const testSelector = fallbackPath.join(' > ')
    const testMatches = document.querySelectorAll(testSelector)

    if (testMatches.length === 1 && testMatches[0] === element) {
      console.log('[ABSmartly] Found minimal fallback selector:', testSelector)
      return testSelector
    }

    if (foundUniqueId) break
  }

  // If still not unique (shouldn't happen), return the full path
  const selector = pathElements.map((elem, i) => {
    let sel = elem.tagName.toLowerCase()
    if (elem.parentElement && i > 0) {
      const siblings = Array.from(elem.parentElement.children)
      if (siblings.length > 1) {
        const idx = siblings.indexOf(elem) + 1
        sel += ':nth-child(' + idx + ')'
      }
    }
    return sel
  }).reverse().join(' > ')

  // Handle edge case of empty selector
  if (!selector) {
    return element.tagName.toLowerCase()
  }

  console.log('[ABSmartly] Final selector:', selector, 'Matches:', document.querySelectorAll(selector).length)
  return selector
}
/**
 * Advanced selector generator that creates robust selectors
 * avoiding auto-generated classes when possible
 */

// Patterns that indicate auto-generated or framework-specific classes
const AUTO_GENERATED_PATTERNS = [
  /^framer-[a-zA-Z0-9]+$/,  // Framer classes like framer-F46SA
  /^[a-z]{1,3}-[a-f0-9]{6,}$/i,  // Hash-based classes
  /^css-[a-z0-9]+$/i,  // CSS modules
  /^sc-[a-zA-Z0-9]+$/,  // Styled-components
  /^[a-zA-Z0-9]{8,}$/,  // Long random strings
  /^v-[a-f0-9]{8}$/,  // Vue scoped classes
  /^svelte-[a-z0-9]+$/,  // Svelte classes
  /^emotion-[0-9]+$/,  // Emotion CSS
  /^chakra-[a-z]+__[a-z]+-[a-z0-9]+$/,  // Chakra UI
  /^MuiBox-root-[0-9]+$/,  // Material-UI
]

// Temporary state classes (already defined in selector-cleaner, but repeated for clarity)
const TEMPORARY_CLASSES = [
  'hover', 'active', 'focus', 'focused', 'selected', 'disabled',
  'loading', 'animating', 'transitioning', 'entering', 'leaving',
  'is-hovered', 'is-active', 'is-focused', 'is-selected',
  'framer-hover', 'framer-active', 'framer-v-hover'
]

// Semantic class patterns that are likely stable
const SEMANTIC_PATTERNS = [
  /^(btn|button)/i,
  /^(nav|navigation)/i,
  /^(header|footer|main|sidebar)/i,
  /^(card|modal|dialog|dropdown)/i,
  /^(form|input|field)/i,
  /^(title|heading|text|content)/i,
  /^(primary|secondary|success|warning|error|info)/i,
  /^(large|medium|small|lg|md|sm|xs)/i,
  /^(container|wrapper|section|row|col)/i,
]

interface SelectorOptions {
  preferDataAttributes?: boolean
  includeParentContext?: boolean
  maxParentLevels?: number
  avoidAutoGenerated?: boolean
}

/**
 * Escapes an ID for use in a CSS selector
 * IDs starting with numbers or containing special characters need escaping
 */
function escapeIdForSelector(id: string): string {
  if (!id) return ''
  
  // If ID starts with a digit, we need to escape it
  if (/^\d/.test(id)) {
    // CSS escape for leading digit: \3x where x is the digit
    return '#\\3' + id.charAt(0) + ' ' + id.slice(1).replace(/([^\w-])/g, '\\$1')
  }
  
  // Escape special characters
  return '#' + id.replace(/([^\w-])/g, '\\$1')
}

/**
 * Checks if an ID is valid for CSS selectors (without escaping)
 */
function isValidCssId(id: string): boolean {
  // IDs starting with numbers or containing special chars need escaping
  return /^[a-zA-Z][\w-]*$/.test(id)
}

/**
 * Validates a CSS selector by trying to use it
 */
function isValidSelector(selector: string): boolean {
  try {
    document.querySelector(selector)
    return true
  } catch (e) {
    return false
  }
}

export function generateRobustSelector(
  element: Element,
  options: SelectorOptions = {}
): string {
  const {
    preferDataAttributes = true,
    includeParentContext = true,
    maxParentLevels = 2,
    avoidAutoGenerated = true
  } = options

  // 1. Try ID (if not auto-generated and valid)
  if (element.id && !isAutoGenerated(element.id)) {
    // Check if ID is valid for CSS
    if (isValidCssId(element.id)) {
      return `#${element.id}`
    } else {
      // If ID starts with number or has special chars, skip it
      // We could escape it, but these are often auto-generated anyway
      console.log('Skipping invalid CSS ID:', element.id)
    }
  }

  // 2. Try data attributes
  if (preferDataAttributes) {
    const dataSelector = getDataAttributeSelector(element)
    if (dataSelector) {
      const matches = document.querySelectorAll(dataSelector)
      if (matches.length === 1) {
        return dataSelector
      }
      // If not unique, we'll combine with parent context later
    }
  }

  // 3. Try semantic classes
  const semanticClasses = getSemanticClasses(element)
  if (semanticClasses.length > 0) {
    const tagName = element.tagName.toLowerCase()
    const classSelector = `${tagName}.${semanticClasses.join('.')}`
    
    // Validate selector before using it
    try {
      const matches = document.querySelectorAll(classSelector)
      if (matches.length === 1) {
        return classSelector
      }
      
      // If not unique but we have semantic classes, try with parent context
      if (includeParentContext && matches.length > 1) {
        const parentSelector = getParentContext(element, maxParentLevels)
        if (parentSelector) {
          const contextualSelector = `${parentSelector} ${classSelector}`
          try {
            if (document.querySelectorAll(contextualSelector).length === 1) {
              return contextualSelector
            }
          } catch (e) {
            console.log('Invalid contextual selector:', contextualSelector, e)
          }
        }
      }
    } catch (e) {
      console.log('Invalid selector generated:', classSelector, e)
    }
  }

  // 4. Try aria attributes
  const ariaSelector = getAriaSelector(element)
  if (ariaSelector) {
    const matches = document.querySelectorAll(ariaSelector)
    if (matches.length === 1) {
      return ariaSelector
    }
  }

  // 5. Try text content for buttons/links
  const textSelector = getTextContentSelector(element)
  if (textSelector) {
    const matches = document.querySelectorAll(textSelector)
    if (matches.length === 1) {
      return textSelector
    }
  }

  // 6. Build a contextual selector with parent elements
  if (includeParentContext) {
    const contextSelector = buildContextualSelector(element, maxParentLevels)
    if (contextSelector) {
      // Clean up any auto-generated classes from the final selector
      // This handles cases like "div > div > a.framer-v-4yns67"
      const cleanedSelector = contextSelector.replace(/\.(framer-[a-zA-Z0-9-]+|css-[a-z0-9]+|sc-[a-zA-Z0-9]+)/g, '')
      return cleanedSelector
    }
  }

  // 7. Last resort: use position-based selector
  return buildPositionalSelector(element)
}

function isAutoGenerated(str: string): boolean {
  // IDs starting with numbers are likely auto-generated
  if (/^\d/.test(str)) {
    return true
  }

  return AUTO_GENERATED_PATTERNS.some(pattern => pattern.test(str))
}

function isDynamicValue(value: string): boolean {
  // Skip values that are dynamic or unsuitable for CSS selectors

  // Check if it's JSON
  if (value.startsWith('{') || value.startsWith('[')) {
    try {
      JSON.parse(value)
      return true // It's valid JSON, skip it
    } catch {
      // Not valid JSON, but still might be malformed JSON attempt
      if (value.includes('":') || value.includes("':")) {
        return true
      }
    }
  }

  // Check if it's a URL
  if (value.includes('://') || value.startsWith('http') || value.startsWith('//')) {
    return true
  }

  // Check if it contains quotes that would break CSS selectors
  if (value.includes('"') || value.includes("'")) {
    return true
  }

  // Check if it's base64 encoded data
  if (value.startsWith('data:') || /^[A-Za-z0-9+/]{50,}={0,2}$/.test(value)) {
    return true
  }

  // Check if it contains special characters that might break selectors
  if (value.includes('\n') || value.includes('\r') || value.includes('\t')) {
    return true
  }

  // Check if value is too long (likely dynamic content)
  if (value.length > 100) {
    return true
  }

  return false
}

function isTemporaryClass(className: string): boolean {
  return TEMPORARY_CLASSES.includes(className) || 
         /^(hover|active|focus)[-_]/i.test(className)
}

function isSemanticClass(className: string): boolean {
  return SEMANTIC_PATTERNS.some(pattern => pattern.test(className))
}

function getSemanticClasses(element: Element): string[] {
  if (!element.className || typeof element.className !== 'string') {
    return []
  }

  return element.className
    .trim()
    .split(/\s+/)
    .filter(cls => 
      cls &&
      !isTemporaryClass(cls) &&
      !isAutoGenerated(cls) &&
      (isSemanticClass(cls) || cls.length < 20) // Prefer shorter, likely human-readable classes
    )
}

function getDataAttributeSelector(element: Element): string | null {
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => {
      // Skip non-data attributes
      if (!attr.name.startsWith('data-')) return false
      
      // Skip React and framework internal attributes
      if (attr.name.includes('reactid') || 
          attr.name.includes('key') ||
          attr.name.includes('framer')) return false
      
      // Skip if the value looks auto-generated
      // Auto-generated values often start with numbers or are random strings
      if (attr.value && (
        /^\d/.test(attr.value) || // Starts with number
        /^[a-f0-9]{6,}$/i.test(attr.value) || // Hex string
        isAutoGenerated(attr.value) || // Use our existing check
        isDynamicValue(attr.value) // Skip dynamic/complex values
      )) {
        return false
      }

      return true
    })

  if (dataAttrs.length === 0) return null

  // Prefer certain data attributes
  const preferredAttrs = ['data-testid', 'data-test', 'data-cy', 'data-id', 'data-name']
  const preferred = dataAttrs.find(attr => preferredAttrs.includes(attr.name))
  
  if (preferred && !isAutoGenerated(preferred.value) && !isDynamicValue(preferred.value)) {
    // Use CSS.escape to properly escape the value for use in a selector
    return `[${preferred.name}="${CSS.escape(preferred.value)}"]`
  }

  // Use the first non-auto-generated and non-dynamic data attribute
  const goodAttr = dataAttrs.find(attr => !isAutoGenerated(attr.value) && !isDynamicValue(attr.value))
  if (goodAttr) {
    // Use CSS.escape to properly escape the value for use in a selector
    return `[${goodAttr.name}="${CSS.escape(goodAttr.value)}"]`
  }
  
  // No good data attributes found
  return null
}

function getAriaSelector(element: Element): string | null {
  const ariaLabel = element.getAttribute('aria-label')
  if (ariaLabel && !isDynamicValue(ariaLabel)) {
    return `[aria-label="${CSS.escape(ariaLabel)}"]`
  }

  const role = element.getAttribute('role')
  if (role && role !== 'presentation' && role !== 'none' && !isDynamicValue(role)) {
    const tagName = element.tagName.toLowerCase()
    return `${tagName}[role="${CSS.escape(role)}"]`
  }

  return null
}

function getTextContentSelector(element: Element): string | null {
  const tagName = element.tagName.toLowerCase()
  
  // Only use text content for specific elements
  if (!['button', 'a', 'label'].includes(tagName)) {
    return null
  }

  const text = element.textContent?.trim()
  if (!text || text.length > 50) {
    return null
  }

  // Check if this text is unique for this element type
  const selector = `${tagName}:contains("${text}")`
  // Note: :contains is not standard CSS, but we can use XPath or implement custom matching
  // For now, return null as this would need special handling
  return null
}

function getParentContext(element: Element, maxLevels: number): string | null {
  let parent = element.parentElement
  let level = 0
  const contextParts: string[] = []

  while (parent && level < maxLevels && parent !== document.body) {
    // Try to get a meaningful selector for the parent
    if (parent.id && !isAutoGenerated(parent.id)) {
      contextParts.unshift(`#${parent.id}`)
      break // ID is unique, no need to go further
    }

    const semanticClasses = getSemanticClasses(parent)
    if (semanticClasses.length > 0) {
      const tagName = parent.tagName.toLowerCase()
      contextParts.unshift(`${tagName}.${semanticClasses[0]}`)
      break // One good parent selector is usually enough
    }

    const dataSelector = getDataAttributeSelector(parent)
    if (dataSelector) {
      contextParts.unshift(dataSelector)
      break
    }

    parent = parent.parentElement
    level++
  }

  return contextParts.length > 0 ? contextParts.join(' ') : null
}

function buildContextualSelector(element: Element, maxParentLevels: number): string | null {
  const parts: string[] = []
  let current: Element | null = element
  let level = 0

  while (current && level <= maxParentLevels) {
    const part = getSelectorPart(current, level === 0)
    if (part) {
      parts.unshift(part)
      
      // Check if this selector is unique
      const selector = parts.join(' > ')
      if (document.querySelectorAll(selector).length === 1) {
        return selector
      }
    }

    if (current.id && !isAutoGenerated(current.id)) {
      // If we found a good ID, rebuild the selector from this point
      const idSelector = `#${current.id}`
      if (parts.length > 1) {
        return `${idSelector} > ${parts.slice(1).join(' > ')}`
      }
      return idSelector
    }

    current = current.parentElement
    level++
  }

  return parts.length > 0 ? parts.join(' > ') : null
}

function getSelectorPart(element: Element, isTarget: boolean): string {
  const tagName = element.tagName.toLowerCase()
  const attributes: string[] = []
  
  // Check for name attribute (commonly used in visual tools)
  const nameAttr = element.getAttribute('name')
  if (nameAttr && !isAutoGenerated(nameAttr)) {
    attributes.push(`[name="${nameAttr}"]`)
  }
  
  // Check for data-*name* attributes (data-name, data-component-name, etc.)
  const dataNameAttrs = Array.from(element.attributes)
    .filter(attr => 
      attr.name.startsWith('data-') && 
      attr.name.toLowerCase().includes('name') &&
      attr.value &&
      !isAutoGenerated(attr.value)
    )
  
  dataNameAttrs.forEach(attr => {
    attributes.push(`[${attr.name}="${attr.value}"]`)
  })
  
  // For the target element, try to be more specific
  if (isTarget) {
    const semanticClasses = getSemanticClasses(element)
    
    // Build selector with tag + attributes + classes
    let selector = tagName
    
    // Add attributes first (more specific than classes)
    if (attributes.length > 0) {
      selector += attributes.join('')
    }
    
    // Add semantic classes
    if (semanticClasses.length > 0) {
      selector += `.${semanticClasses.join('.')}`
    }
    
    // If we have some identifying features, return them
    if (attributes.length > 0 || semanticClasses.length > 0) {
      return selector
    }

    // Try other data attributes
    const dataSelector = getDataAttributeSelector(element)
    if (dataSelector) {
      return `${tagName}${dataSelector}`
    }
    
    // If no semantic classes or data attributes, use positional selector
    // This is crucial for Framer sites where all classes are auto-generated
    if (element.parentElement) {
      const siblings = Array.from(element.parentElement.children)
        .filter(child => child.tagName === element.tagName)
      if (siblings.length > 1) {
        const index = siblings.indexOf(element) + 1
        // Add any name attributes even with positional selector
        if (attributes.length > 0) {
          return `${tagName}:nth-of-type(${index})${attributes.join('')}`
        }
        return `${tagName}:nth-of-type(${index})`
      }
    }
    
    // Return tag with any attributes we found
    return attributes.length > 0 ? `${tagName}${attributes.join('')}` : tagName
  }

  // For parent elements, be less specific but still include name attributes
  let selector = tagName
  
  // Add name attributes for parent elements too
  if (attributes.length > 0) {
    selector += attributes[0] // Just use the first attribute for parents
  } else {
    const semanticClasses = getSemanticClasses(element)
    if (semanticClasses.length > 0) {
      selector += `.${semanticClasses[0]}`
    }
  }

  // Use nth-of-type for uniqueness if needed
  if (element.parentElement && selector === tagName) {
    const siblings = Array.from(element.parentElement.children)
      .filter(child => child.tagName === element.tagName)
    if (siblings.length > 1) {
      const index = siblings.indexOf(element) + 1
      return `${tagName}:nth-of-type(${index})`
    }
  }

  return selector
}

function buildPositionalSelector(element: Element): string {
  const parts: string[] = []
  let current: Element | null = element

  while (current && current !== document.body) {
    const tagName = current.tagName.toLowerCase()
    
    if (current.parentElement) {
      const siblings = Array.from(current.parentElement.children)
        .filter(child => child.tagName === current!.tagName)
      
      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1
        parts.unshift(`${tagName}:nth-of-type(${index})`)
      } else {
        parts.unshift(tagName)
      }
    } else {
      parts.unshift(tagName)
    }

    // Stop if we've built enough context
    if (parts.length >= 3) {
      break
    }

    current = current.parentElement
  }

  return parts.join(' > ')
}

export function improveSelector(selector: string): string {
  // This function can be used to improve existing selectors
  // by removing auto-generated classes and adding parent context
  
  // Parse the selector and try to improve it
  // This is a simplified version - a full implementation would need a CSS selector parser
  
  try {
    const elements = document.querySelectorAll(selector)
    if (elements.length === 1) {
      // Selector is already unique, try to simplify it
      return generateRobustSelector(elements[0], {
        preferDataAttributes: true,
        includeParentContext: true,
        avoidAutoGenerated: true
      })
    } else if (elements.length === 0) {
      // Selector doesn't match anything
      return selector // Can't improve
    } else {
      // Multiple matches - selector is not specific enough
      // Would need more context to improve
      return selector
    }
  } catch (e) {
    // Invalid selector
    return selector
  }
}
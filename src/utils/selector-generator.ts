/**
 * Advanced selector generator that creates robust selectors
 * avoiding auto-generated classes when possible
 */

// Patterns that indicate auto-generated or framework-specific classes
const AUTO_GENERATED_PATTERNS = [
  /^framer-[a-zA-Z0-9]+$/,  // Framer classes like framer-F46SA
  /^css-[a-z0-9]+$/i,  // CSS modules
  /^sc-[a-zA-Z0-9]+$/,  // Styled-components
  /^v-[a-f0-9]{8}$/,  // Vue scoped classes
  /^svelte-[a-z0-9]+$/,  // Svelte classes
  /^emotion-[0-9]+$/,  // Emotion CSS
  /^chakra-[a-z]+__[a-z]+-[a-z0-9]+$/,  // Chakra UI
  /^MuiBox-root-[0-9]+$/,  // Material-UI
  /^[a-f0-9]{8,}$/i,  // Hex strings (UUIDs, hashes)
  /_[a-f0-9]{6,}$/i,  // Ending with hex strings
]

// Temporary state classes (already defined in selector-cleaner, but repeated for clarity)
const TEMPORARY_CLASSES = [
  'hover', 'active', 'focus', 'focused', 'selected', 'disabled',
  'loading', 'animating', 'transitioning', 'entering', 'leaving',
  'is-hovered', 'is-active', 'is-focused', 'is-selected',
  'framer-hover', 'framer-active', 'framer-v-hover'
]

// Semantic class patterns that are likely stable
const SEMANTIC_PATTERNS = [
  /^(btn|button)/i,
  /^(nav|navigation)/i,
  /^(header|footer|main|sidebar)/i,
  /^(card|modal|dialog|dropdown)/i,
  /^(form|input|field)/i,
  /^(title|heading|text|content)/i,
  /^(primary|secondary|success|warning|error|info)/i,
  /^(large|medium|small|lg|md|sm|xs)/i,
  /^(container|wrapper|section|row|col)/i,
]

interface SelectorOptions {
  preferDataAttributes?: boolean
  includeParentContext?: boolean
  maxParentLevels?: number
  avoidAutoGenerated?: boolean
  debug?: boolean
}

/**
 * Escapes an ID for use in a CSS selector
 * IDs starting with numbers or containing special characters need escaping
 */
function escapeIdForSelector(id: string): string {
  if (!id) return ''
  
  // If ID starts with a digit, we need to escape it
  if (/^\d/.test(id)) {
    // CSS escape for leading digit: \3x where x is the digit
    return '#\\3' + id.charAt(0) + ' ' + id.slice(1).replace(/([^\w-])/g, '\\$1')
  }
  
  // Escape special characters
  return '#' + id.replace(/([^\w-])/g, '\\$1')
}

/**
 * Checks if an ID is valid for CSS selectors (without escaping)
 */
function isValidCssId(id: string): boolean {
  // IDs starting with numbers or containing special chars need escaping
  return /^[a-zA-Z][\w-]*$/.test(id)
}

/**
 * Validates a CSS selector by trying to use it
 */
function isValidSelector(selector: string): boolean {
  try {
    document.querySelector(selector)
    return true
  } catch (e) {
    return false
  }
}

export function generateRobustSelector(
  element: Element,
  options: SelectorOptions = {}
): string {
  const {
    preferDataAttributes = true,
    includeParentContext = true,
    maxParentLevels = 2,
    avoidAutoGenerated = true,
    debug = false
  } = options || {}

  // Store debug flag globally so helper functions can access it
  if (typeof window !== 'undefined') {
    (window as any).__selectorDebug = debug
  }

  // 1. Try ID (if not auto-generated and valid)
  if (element.id && !isAutoGenerated(element.id)) {
    // Check if ID is valid for CSS
    if (isValidCssId(element.id)) {
      return `#${element.id}`
    } else {
      // If ID starts with number or has special chars, skip it
      // We could escape it, but these are often auto-generated anyway
      console.log('Skipping invalid CSS ID:', element.id)
    }
  }

  // 2. Try data attributes
  if (preferDataAttributes) {
    const dataSelector = getDataAttributeSelector(element)
    if (dataSelector) {
      const matches = document.querySelectorAll(dataSelector)
      if (matches.length === 1) {
        return dataSelector
      }
      // If not unique, we'll combine with parent context later
    }
  }

  // 3. Try semantic classes
  const semanticClasses = getSemanticClasses(element)
  if (semanticClasses.length > 0) {
    const tagName = element.tagName.toLowerCase()
    const classSelector = `${tagName}.${semanticClasses.join('.')}`
    
    // Validate selector before using it
    try {
      const matches = document.querySelectorAll(classSelector)
      if (matches.length === 1) {
        return classSelector
      }
      
      // If not unique but we have semantic classes, try with parent context
      if (includeParentContext && matches.length > 1) {
        const parentSelector = getParentContext(element, maxParentLevels)
        if (parentSelector) {
          const contextualSelector = `${parentSelector} ${classSelector}`
          try {
            if (document.querySelectorAll(contextualSelector).length === 1) {
              return contextualSelector
            }
          } catch (e) {
            console.log('Invalid contextual selector:', contextualSelector, e)
          }
        }
      }
    } catch (e) {
      console.log('Invalid selector generated:', classSelector, e)
    }
  }

  // 4. Try aria attributes
  const ariaSelector = getAriaSelector(element)
  if (ariaSelector) {
    const matches = document.querySelectorAll(ariaSelector)
    if (matches.length === 1) {
      return ariaSelector
    }
  }

  // 5. Try text content for buttons/links
  const textSelector = getTextContentSelector(element)
  if (textSelector) {
    const matches = document.querySelectorAll(textSelector)
    if (matches.length === 1) {
      return textSelector
    }
  }

  // 6. Build a contextual selector with parent elements
  if (includeParentContext) {
    const contextSelector = buildContextualSelector(element, maxParentLevels)
    if (contextSelector) {
      // Clean up any auto-generated classes from the final selector
      // This handles cases like "div > div > a.framer-v-4yns67"
      const cleanedSelector = contextSelector.replace(/\.(framer-[a-zA-Z0-9-]+|css-[a-z0-9]+|sc-[a-zA-Z0-9]+)/g, '')
      return cleanedSelector
    }
  }

  // 7. Last resort: use position-based selector
  return buildPositionalSelector(element)
}

/**
 * Calculate normalized entropy score for a string (0-1 range)
 * Higher entropy = more random distribution of characters
 */
function calculateEntropy(str: string): number {
  if (!str || str.length === 0) return 0

  // Count character frequencies
  const frequencies = new Map<string, number>()
  for (const char of str) {
    frequencies.set(char, (frequencies.get(char) || 0) + 1)
  }

  // Calculate Shannon entropy
  let entropy = 0
  const len = str.length
  for (const count of frequencies.values()) {
    const probability = count / len
    entropy -= probability * Math.log2(probability)
  }

  // Normalize to 0-1 range (max entropy for string length)
  const maxEntropy = Math.log2(len)
  return maxEntropy > 0 ? entropy / maxEntropy : 0
}

/**
 * Check if string has long consonant clusters (4+ consonants in a row)
 * Language-independent indicator of random generation
 */
function hasLongConsonantCluster(str: string): boolean {
  // Remove digits and check for 4+ non-vowel letters in a row
  const lettersOnly = str.replace(/[0-9]/g, '')
  return /[^aeiouAEIOU]{4,}/.test(lettersOnly)
}

export function isAutoGenerated(str: string): boolean {
  // 1. IDs starting with numbers are likely auto-generated
  if (/^\d/.test(str)) {
    return true
  }

  // 2. Check for framework-specific patterns
  if (AUTO_GENERATED_PATTERNS.some(pattern => pattern.test(str))) {
    return true
  }

  // 3. Check for hex-like strings (6+ hex chars)
  if (/^[a-f0-9]{6,}$/i.test(str)) {
    return true
  }

  // Extract potential random segments (split by common separators)
  const segments = str.split(/[-_\s]/)

  for (const segment of segments) {
    // Skip short segments or empty ones
    if (!segment || segment.length < 6) continue

    // Count character types
    const upperCount = (segment.match(/[A-Z]/g) || []).length
    const lowerCount = (segment.match(/[a-z]/g) || []).length
    const digitCount = (segment.match(/[0-9]/g) || []).length

    // Skip if no mixed case (pure lowercase/uppercase are usually OK)
    if (upperCount === 0 || lowerCount === 0) {
      continue
    }

    // 4. ENTROPY CHECK (primary indicator)
    const entropy = calculateEntropy(segment)
    const hasHighEntropy = entropy > 0.85 // Threshold: 85% of maximum entropy

    // 5. CONSONANT CLUSTER CHECK (language-independent)
    const hasConsonantCluster = hasLongConsonantCluster(segment)

    // 6. CASE TRANSITION CHECK
    const caseTransitions = (segment.match(/[a-z][A-Z]/g) || []).length
    const hasMultipleTransitions = caseTransitions > 2 // More than typical camelCase

    // 7. DIGIT PLACEMENT CHECK
    const hasDigitsInMiddle = /[0-9].*[a-zA-Z]/.test(segment)
    const hasDigitsAtEnd = digitCount > 0 && /[0-9]$/.test(segment)

    // DETECTION LOGIC: Combine multiple signals
    // We need at least TWO indicators to avoid false positives
    let signalCount = 0
    if (hasHighEntropy) signalCount++
    if (hasConsonantCluster && caseTransitions > 0) signalCount++ // Consonant cluster only counts if mixed case
    if (hasMultipleTransitions) signalCount++
    if (hasDigitsInMiddle && digitCount > 0) signalCount++
    if (hasDigitsAtEnd && upperCount >= 2 && lowerCount >= 2) signalCount++ // Digits at end with mixed case

    // Require at least 2 signals for detection (reduces false positives)
    if (signalCount >= 2) {
      return true
    }
  }

  return false
}

function isDynamicValue(value: string): boolean {
  // Skip values that are dynamic or unsuitable for CSS selectors

  // Check if it's JSON
  if (value.startsWith('{') || value.startsWith('[')) {
    try {
      JSON.parse(value)
      return true // It's valid JSON, skip it
    } catch {
      // Not valid JSON, but still might be malformed JSON attempt
      if (value.includes('":') || value.includes("':")) {
        return true
      }
    }
  }

  // Check if it's a URL
  if (value.includes('://') || value.startsWith('http') || value.startsWith('//')) {
    return true
  }

  // Check if it contains quotes that would break CSS selectors
  if (value.includes('"') || value.includes("'")) {
    return true
  }

  // Check if it's base64 encoded data
  if (value.startsWith('data:') || /^[A-Za-z0-9+/]{50,}={0,2}$/.test(value)) {
    return true
  }

  // Check if it contains special characters that might break selectors
  if (value.includes('\n') || value.includes('\r') || value.includes('\t')) {
    return true
  }

  // Check if value is too long (likely dynamic content)
  if (value.length > 100) {
    return true
  }

  return false
}

function isTemporaryClass(className: string): boolean {
  return TEMPORARY_CLASSES.includes(className) || 
         /^(hover|active|focus)[-_]/i.test(className)
}

function isSemanticClass(className: string): boolean {
  return SEMANTIC_PATTERNS.some(pattern => pattern.test(className))
}

function getSemanticClasses(element: Element): string[] {
  if (!element.className || typeof element.className !== 'string') {
    return []
  }

  return element.className
    .trim()
    .split(/\s+/)
    .filter(cls =>
      cls &&
      !cls.includes('absmartly') && // Skip ABSmartly-added classes
      !isTemporaryClass(cls) &&
      !isAutoGenerated(cls) &&
      (isSemanticClass(cls) || cls.length < 20) // Prefer shorter, likely human-readable classes
    )
}

function getDataAttributeSelector(element: Element): string | null {
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => {
      // Skip non-data attributes
      if (!attr.name.startsWith('data-')) return false

      // CRITICAL: Skip ABSmartly-added attributes to avoid circular dependencies
      if (attr.name.startsWith('data-absmartly')) return false

      // Skip if the value looks auto-generated, dynamic, or unsuitable
      // Filter on VALUE, not attribute name
      if (attr.value && (
        /^\d/.test(attr.value) || // Starts with number
        /^[a-f0-9]{6,}$/i.test(attr.value) || // Hex string
        isAutoGenerated(attr.value) || // Use our existing check
        isDynamicValue(attr.value) // Skip dynamic/complex values
      )) {
        return false
      }

      return true
    })

  if (dataAttrs.length === 0) return null

  // Prefer attributes with "name" or "id" in the attribute name (more semantic)
  const preferred = dataAttrs.find(attr =>
    attr.name.includes('name') || attr.name.includes('id')
  )

  if (preferred) {
    return `[${preferred.name}="${CSS.escape(preferred.value)}"]`
  }

  // Use the first available data attribute
  if (dataAttrs.length > 0) {
    const attr = dataAttrs[0]
    return `[${attr.name}="${CSS.escape(attr.value)}"]`
  }

  // No good data attributes found
  return null
}

function getAriaSelector(element: Element): string | null {
  const ariaLabel = element.getAttribute('aria-label')
  if (ariaLabel && !isDynamicValue(ariaLabel)) {
    return `[aria-label="${CSS.escape(ariaLabel)}"]`
  }

  const role = element.getAttribute('role')
  if (role && role !== 'presentation' && role !== 'none' && !isDynamicValue(role)) {
    const tagName = element.tagName.toLowerCase()
    return `${tagName}[role="${CSS.escape(role)}"]`
  }

  return null
}

function getTextContentSelector(element: Element): string | null {
  const tagName = element.tagName.toLowerCase()
  
  // Only use text content for specific elements
  if (!['button', 'a', 'label'].includes(tagName)) {
    return null
  }

  const text = element.textContent?.trim()
  if (!text || text.length > 50) {
    return null
  }

  // Check if this text is unique for this element type
  const selector = `${tagName}:contains("${text}")`
  // Note: :contains is not standard CSS, but we can use XPath or implement custom matching
  // For now, return null as this would need special handling
  return null
}

function getParentContext(element: Element, maxLevels: number): string | null {
  let parent = element.parentElement
  let level = 0
  const contextParts: string[] = []

  while (parent && level < maxLevels && parent !== document.body) {
    // Try to get a meaningful selector for the parent
    if (parent.id && !isAutoGenerated(parent.id)) {
      contextParts.unshift(`#${parent.id}`)
      break // ID is unique, no need to go further
    }

    const semanticClasses = getSemanticClasses(parent)
    if (semanticClasses.length > 0) {
      const tagName = parent.tagName.toLowerCase()
      contextParts.unshift(`${tagName}.${semanticClasses[0]}`)
      break // One good parent selector is usually enough
    }

    const dataSelector = getDataAttributeSelector(parent)
    if (dataSelector) {
      contextParts.unshift(dataSelector)
      break
    }

    parent = parent.parentElement
    level++
  }

  return contextParts.length > 0 ? contextParts.join(' ') : null
}

function getSemanticScore(element: Element): number {
  let score = 0

  // High-value attributes (most stable and unique)
  if (element.hasAttribute('data-testid')) score += 100
  if (element.hasAttribute('data-name')) score += 80

  // Medium-value attributes (data-framer-name)
  const dataFramerName = element.getAttribute('data-framer-name')
  if (dataFramerName && !isAutoGenerated(dataFramerName)) {
    // Prefer section/page-level names (more stable, higher in tree)
    const lowerName = dataFramerName.toLowerCase()
    if (lowerName.includes('section') || lowerName.includes('page') || lowerName.includes('hero')) {
      score += 70  // Much higher score for section-level names
    } else {
      score += 50
    }
  }

  // Other data attributes that might be semantic
  const dataRole = element.getAttribute('data-role')
  if (dataRole && !isAutoGenerated(dataRole)) score += 40

  return score
}

function buildContextualSelector(element: Element, maxParentLevels: number): string | null {
  const debug = typeof window !== 'undefined' ? (window as any).__selectorDebug : false
  const targetPart = getSelectorPart(element, true)
  const targetTag = element.tagName.toLowerCase()

  if (debug) {
    console.log(`[buildContextualSelector] ===== STARTING SCAN for ${targetTag} =====`)
    console.log(`[buildContextualSelector] Target element:`, element)
    console.log(`[buildContextualSelector] Target part: "${targetPart}"`)
  }

  // Try just the target element first
  if (targetPart && document.querySelectorAll(targetPart).length === 1) {
    if (debug) console.log(`[buildContextualSelector] ✓ Target part is unique: ${targetPart}`)
    return targetPart
  }

  // Collect all ancestors with semantic attributes
  const semanticAncestors: Array<{element: Element, depth: number, score: number}> = []
  let current = element.parentElement
  let depth = 1

  if (debug) console.log(`[buildContextualSelector] Scanning up to ${maxParentLevels} parent levels...`)
  while (current && depth <= maxParentLevels) {
    if (debug) {
      console.log(`[buildContextualSelector] Depth ${depth}: ${current.tagName}`, {
        'data-framer-name': current.getAttribute('data-framer-name'),
        id: current.id || 'none'
      })
    }
    const score = getSemanticScore(current)
    if (score > 0) {
      semanticAncestors.push({ element: current, depth, score })
    }
    current = current.parentElement
    depth++
  }

  // Sort by score DESC (prefer higher quality), then depth ASC (prefer closer)
  semanticAncestors.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score
    return a.depth - b.depth
  })

  if (debug) {
    console.log('[buildContextualSelector] Found semantic ancestors:', semanticAncestors.map(a => ({
      depth: a.depth,
      score: a.score,
      tag: a.element.tagName,
      dataFramerName: a.element.getAttribute('data-framer-name')
    })))
  }

  // Try each semantic ancestor from highest scored to lowest
  for (const {element: ancestor, depth: ancestorDepth} of semanticAncestors) {
    const parentPart = getSelectorPart(ancestor, false)
    if (!parentPart) continue

    const selector = `${parentPart} ${targetPart || targetTag}`
    const matches = document.querySelectorAll(selector)

    if (debug) console.log(`[buildContextualSelector] Trying "${selector}" (ancestor depth ${ancestorDepth}): ${matches.length} matches`)

    if (matches.length === 1 && matches[0] === element) {
      if (debug) console.log(`[buildContextualSelector] ✓ Found unique selector: ${selector}`)
      return selector
    }

    // If this selector matches multiple elements, find the disambiguating ancestor
    if (matches.length > 1) {
      if (debug) console.log(`[buildContextualSelector] Selector matched ${matches.length} elements, finding disambiguating parent...`)

      const matchingElements = Array.from(matches)

      // Find the first ancestor level where the matching elements diverge
      let disambiguatingAncestor: Element | null = null
      let checkDepth = 1
      const maxCheckDepth = 10

      while (checkDepth <= maxCheckDepth) {
        // For each matching element, get its ancestor at this depth
        const ancestorsAtDepth = matchingElements.map(match => {
          let current = match as Element
          for (let d = 0; d < checkDepth && current.parentElement; d++) {
            current = current.parentElement
          }
          return current
        })

        // Find our target element's ancestor at this depth
        let ourAncestor = element as Element
        for (let d = 0; d < checkDepth && ourAncestor.parentElement; d++) {
          ourAncestor = ourAncestor.parentElement
        }

        if (debug) {
          const otherAncestorInfo = ancestorsAtDepth.map(a => ({
            tag: a.tagName,
            attr: a.getAttribute('data-framer-name'),
            isSame: a === ourAncestor
          }))
          console.log(`[buildContextualSelector] Checking depth ${checkDepth}:`)
          console.log(`  Our ancestor: ${ourAncestor.tagName}[data-framer-name="${ourAncestor.getAttribute('data-framer-name')}"]`)
          console.log(`  Other matching elements' ancestors:`, otherAncestorInfo)
        }

        // Check if this ancestor has a semantic attribute that disambiguates
        const semanticAttr = ourAncestor.getAttribute('data-framer-name') || ourAncestor.getAttribute('data-name')
        if (semanticAttr && !isAutoGenerated(semanticAttr)) {
          // Check if ALL other matching elements have DIFFERENT semantic attribute values
          // Not just different element instances, but different attribute values!
          const otherAttrValues = ancestorsAtDepth.map(a => {
            const attr = a.getAttribute('data-framer-name') || a.getAttribute('data-name')
            return { isSameElement: a === ourAncestor, attrValue: attr }
          })

          const otherHaveDifferentValues = ancestorsAtDepth.every(a => {
            if (a === ourAncestor) return true // Same element is fine (it's our target's match)
            const otherAttr = a.getAttribute('data-framer-name') || a.getAttribute('data-name')
            return otherAttr !== semanticAttr // Different attribute value
          })

          if (debug) {
            console.log(`  Checking semantic attr "${semanticAttr}":`, {
              otherAttrValues,
              otherHaveDifferentValues
            })
          }

          if (otherHaveDifferentValues) {
            // Test if this ancestor actually creates a unique selector
            const disambiguatingPart = getSelectorPart(ourAncestor, false)
            if (disambiguatingPart) {
              // Try two approaches:
              // 1. ancestor + intermediate selector (e.g., "Features" + "Feature:nth-of-type(1) p")
              // 2. ancestor + target only (e.g., "Features Row 1" + "p")

              if (debug) {
                console.log(`  disambiguatingPart = "${disambiguatingPart}" (checkDepth ${checkDepth})`)
                console.log(`  selector (from outer loop) = "${selector}" (ancestorDepth ${ancestorDepth})`)
              }

              // Determine the correct order based on DOM hierarchy
              // checkDepth is the distance from the matched elements (p tags)
              // ancestorDepth is the distance from the original target element
              // If checkDepth < ancestorDepth, disambiguating ancestor is closer to target (should come after semantic parent)
              // If checkDepth > ancestorDepth, disambiguating ancestor is farther from target (should come before semantic parent)

              // Build a selector chain from disambiguating ancestor down to target
              // Start with the disambiguating ancestor and walk down to the target element
              // For each step, use semantic attributes if available, otherwise use tag + :nth-of-type()
              // Use child combinator (>) for non-semantic elements to ensure precise targeting

              let currentSelector = disambiguatingPart
              let currentElement = ourAncestor

              // Build path from disambiguating ancestor to target
              const pathToTarget: Element[] = []
              let tempElement: Element | null = element
              while (tempElement && tempElement !== ourAncestor) {
                pathToTarget.unshift(tempElement)
                tempElement = tempElement.parentElement
              }

              if (debug) console.log(`  Building chain from "${disambiguatingPart}" through ${pathToTarget.length} elements to target`)

              // Build selector incrementally, validating at each step
              for (let i = 0; i < pathToTarget.length; i++) {
                const pathElement = pathToTarget[i]
                const parent = i === 0 ? ourAncestor : pathToTarget[i - 1]

                // Try to get semantic selector first
                const semanticPart = getSelectorPart(pathElement, false)
                const tag = pathElement.tagName.toLowerCase()

                // Check if semanticPart actually has semantic information (not just a tag name)
                const hasSemantic = semanticPart && semanticPart !== tag

                if (hasSemantic) {
                  // Has semantic attributes, use descendant combinator
                  currentSelector = `${currentSelector} ${semanticPart}`
                  if (debug) console.log(`    [${i}] Added semantic: ${semanticPart}`)
                } else {
                  // No semantic attributes, use tag + :nth-of-type() with child combinator
                  const siblings = Array.from(parent.children).filter(
                    child => child.tagName === pathElement.tagName
                  )

                  if (debug) console.log(`    [${i}] Non-semantic ${tag}, ${siblings.length} siblings`)

                  if (siblings.length > 1) {
                    const index = siblings.indexOf(pathElement) + 1
                    currentSelector = `${currentSelector} > ${tag}:nth-of-type(${index})`
                    if (debug) console.log(`    [${i}] Added with nth: ${tag}:nth-of-type(${index})`)
                  } else {
                    currentSelector = `${currentSelector} > ${tag}`
                    if (debug) console.log(`    [${i}] Added without nth: ${tag}`)
                  }
                }
              }

              const chainedMatches = document.querySelectorAll(currentSelector)

              if (debug) console.log(`  Testing chained selector: "${currentSelector}": ${chainedMatches.length} matches`)

              if (chainedMatches.length === 1 && chainedMatches[0] === element) {
                if (debug) console.log(`[buildContextualSelector] ✓ Found unique selector with chained path at depth ${checkDepth}`)
                return currentSelector
              }

              // If neither worked, continue searching deeper
            }
          }
        }

        checkDepth++
      }
    }
  }

  // If semantic ancestors didn't work, try all ancestors (including non-semantic)
  current = element.parentElement
  depth = 1

  while (current && depth <= maxParentLevels) {
    const parentPart = getSelectorPart(current, false)

    if (parentPart) {
      const selector = `${parentPart} ${targetPart || targetTag}`
      if (document.querySelectorAll(selector).length === 1) {
        return selector
      }
    }

    // Check if parent has a good ID
    if (current.id && !isAutoGenerated(current.id)) {
      const idSelector = `#${current.id}`
      const selector = `${idSelector} ${targetPart || targetTag}`
      if (document.querySelectorAll(selector).length === 1) {
        return selector
      }
    }

    current = current.parentElement
    depth++
  }

  // If we couldn't find a unique selector, return null so the caller can try other strategies
  return null
}

function getSelectorPart(element: Element, isTarget: boolean): string {
  const tagName = element.tagName.toLowerCase()
  const attributes: string[] = []
  
  // Check for name attribute (commonly used in visual tools)
  const nameAttr = element.getAttribute('name')
  if (nameAttr && !isAutoGenerated(nameAttr)) {
    attributes.push(`[name="${nameAttr}"]`)
  }
  
  // Check for data-*name* attributes (data-name, data-component-name, etc.)
  const dataNameAttrs = Array.from(element.attributes)
    .filter(attr => 
      attr.name.startsWith('data-') && 
      attr.name.toLowerCase().includes('name') &&
      attr.value &&
      !isAutoGenerated(attr.value)
    )
  
  dataNameAttrs.forEach(attr => {
    attributes.push(`[${attr.name}="${attr.value}"]`)
  })
  
  // For the target element, try to be more specific
  if (isTarget) {
    const semanticClasses = getSemanticClasses(element)
    
    // Build selector with tag + attributes + classes
    let selector = tagName
    
    // Add attributes first (more specific than classes)
    if (attributes.length > 0) {
      selector += attributes.join('')
    }
    
    // Add semantic classes
    if (semanticClasses.length > 0) {
      selector += `.${semanticClasses.join('.')}`
    }
    
    // If we have some identifying features, check if they're unique among siblings
    if (attributes.length > 0 || semanticClasses.length > 0) {
      // Check if this selector is unique among siblings
      if (element.parentElement) {
        const siblings = Array.from(element.parentElement.children)
        const matchingSiblings = siblings.filter(sibling => {
          if (sibling === element || sibling.tagName !== element.tagName) return false

          // Check if any of our attributes match
          for (const attr of attributes) {
            const attrMatch = attr.match(/\[([^=]+)="([^"]+)"\]/)
            if (attrMatch) {
              const [, attrName, attrValue] = attrMatch
              if (sibling.getAttribute(attrName) === attrValue) return true
            }
          }

          // Check if any of our classes match
          if (semanticClasses.length > 0 && sibling.className) {
            const siblingClasses = sibling.className.toString().split(/\s+/)
            if (semanticClasses.some(cls => siblingClasses.includes(cls))) return true
          }

          return false
        })

        // If we have siblings with same attributes/classes, add position for disambiguation
        if (matchingSiblings.length > 0) {
          const sameTagSiblings = siblings.filter(child => child.tagName === element.tagName)
          const index = sameTagSiblings.indexOf(element) + 1
          return `${selector}:nth-of-type(${index})`
        }
      }

      return selector
    }

    // Try other data attributes
    const dataSelector = getDataAttributeSelector(element)
    if (dataSelector) {
      return `${tagName}${dataSelector}`
    }
    
    // If no semantic classes or data attributes, use positional selector
    // This is crucial for Framer sites where all classes are auto-generated
    if (element.parentElement) {
      const siblings = Array.from(element.parentElement.children)
        .filter(child => child.tagName === element.tagName)
      if (siblings.length > 1) {
        const index = siblings.indexOf(element) + 1
        // Add any name attributes even with positional selector
        if (attributes.length > 0) {
          return `${tagName}:nth-of-type(${index})${attributes.join('')}`
        }
        return `${tagName}:nth-of-type(${index})`
      }
    }
    
    // Return tag with any attributes we found
    return attributes.length > 0 ? `${tagName}${attributes.join('')}` : tagName
  }

  // For parent elements, be less specific but still include name attributes
  let selector = tagName

  // Add name attributes for parent elements too
  if (attributes.length > 0) {
    selector += attributes[0] // Just use the first attribute for parents
  } else {
    const semanticClasses = getSemanticClasses(element)
    if (semanticClasses.length > 0) {
      selector += `.${semanticClasses[0]}`
    }
  }

  // Only add nth-of-type if siblings have the SAME semantic attribute value
  if (element.parentElement && attributes.length > 0) {
    // Extract the attribute name and value from the first attribute
    const attrMatch = attributes[0].match(/\[([^=]+)="([^"]+)"\]/)
    if (attrMatch) {
      const [, attrName, attrValue] = attrMatch

      // Check if siblings have the same attribute value
      const siblingsWithSameAttr = Array.from(element.parentElement.children)
        .filter(s =>
          s !== element &&
          s.tagName === element.tagName &&
          s.getAttribute(attrName) === attrValue
        )

      if (siblingsWithSameAttr.length > 0) {
        // Need nth-of-type for disambiguation
        const allSameTagSiblings = Array.from(element.parentElement.children)
          .filter(s => s.tagName === element.tagName)
        const index = allSameTagSiblings.indexOf(element) + 1
        return `${selector}:nth-of-type(${index})`
      }
    }
  }

  return selector
}

function buildPositionalSelector(element: Element): string {
  const parts: string[] = []
  let current: Element | null = element

  while (current && current !== document.body) {
    const tagName = current.tagName.toLowerCase()

    if (current.parentElement) {
      const siblings = Array.from(current.parentElement.children)
        .filter(child => child.tagName === current!.tagName)

      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1
        parts.unshift(`${tagName}:nth-of-type(${index})`)
      } else {
        parts.unshift(tagName)
      }
    } else {
      parts.unshift(tagName)
    }

    // Stop if we've built enough context
    if (parts.length >= 3) {
      break
    }

    current = current.parentElement
  }

  return parts.join(' ')
}

export function improveSelector(selector: string): string {
  // This function can be used to improve existing selectors
  // by removing auto-generated classes and adding parent context
  
  // Parse the selector and try to improve it
  // This is a simplified version - a full implementation would need a CSS selector parser
  
  try {
    const elements = document.querySelectorAll(selector)
    if (elements.length === 1) {
      // Selector is already unique, try to simplify it
      return generateRobustSelector(elements[0], {
        preferDataAttributes: true,
        includeParentContext: true,
        avoidAutoGenerated: true
      })
    } else if (elements.length === 0) {
      // Selector doesn't match anything
      return selector // Can't improve
    } else {
      // Multiple matches - selector is not specific enough
      // Would need more context to improve
      return selector
    }
  } catch (e) {
    // Invalid selector
    return selector
  }
}
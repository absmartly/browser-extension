/**
 * CSS Selector Generation Strategy
 */

import {
  escapeSelector,
  isAutoGenerated,
  isSemantic,
  testSelectorUniqueness,
  getCleanClasses,
  getParentPath,
  type SelectorOptions
} from './base'

const selectorCache = new WeakMap<Element, Map<string, string>>()

export function generateCSSSelector(
  element: Element,
  options: SelectorOptions = {}
): string {
  if (!element) return ''

  const cacheKey = JSON.stringify(options)
  const elementCache = selectorCache.get(element)
  if (elementCache) {
    const cached = elementCache.get(cacheKey)
    if (cached) {
      return cached
    }
  }

  let result: string

  if (element.id && !isAutoGenerated(element.id)) {
    const idSelector = `#${escapeSelector(element.id)}`
    if (testSelectorUniqueness(idSelector, element)) {
      result = idSelector
      cacheResult(element, cacheKey, result)
      return result
    }
  }

  if (options.preferDataAttributes) {
    const dataSelector = tryDataAttributes(element)
    if (dataSelector && testSelectorUniqueness(dataSelector, element)) {
      result = dataSelector
      cacheResult(element, cacheKey, result)
      return result
    }
  }

  const classSelector = tryClassCombinations(element)
  if (classSelector && testSelectorUniqueness(classSelector, element)) {
    result = classSelector
    cacheResult(element, cacheKey, result)
    return result
  }

  if (options.includeParentContext) {
    const contextSelector = tryWithParentContext(element, options.maxParentLevels)
    if (contextSelector && testSelectorUniqueness(contextSelector, element)) {
      result = contextSelector
      cacheResult(element, cacheKey, result)
      return result
    }
  }

  result = generateNthChildSelector(element)
  cacheResult(element, cacheKey, result)
  return result
}

function cacheResult(element: Element, cacheKey: string, selector: string): void {
  let elementCache = selectorCache.get(element)
  if (!elementCache) {
    elementCache = new Map()
    selectorCache.set(element, elementCache)
  }
  elementCache.set(cacheKey, selector)
}

function tryDataAttributes(element: Element): string | null {
  const dataAttrs = Array.from(element.attributes)
    .filter(attr =>
      attr.name.startsWith('data-') &&
      !attr.name.includes('reactid') &&
      !attr.name.includes('key') &&
      !attr.name.includes('framer') &&
      attr.value &&
      !isAutoGenerated(attr.value)
    )

  for (const attr of dataAttrs) {
    const selector = `[${attr.name}="${escapeSelector(attr.value)}"]`
    if (testSelectorUniqueness(selector, element)) {
      return selector
    }
  }

  return null
}

function tryClassCombinations(element: Element): string | null {
  const classes = getCleanClasses(element)
  if (classes.length === 0) return null

  const semanticClasses = classes.filter(isSemantic)
  const regularClasses = classes.filter(c => !isSemantic(c))

  const classesToTry = [...semanticClasses, ...regularClasses]

  for (let i = 1; i <= Math.min(3, classesToTry.length); i++) {
    const combinations = getCombinations(classesToTry, i)
    for (const combo of combinations) {
      const selector = combo.map(c => `.${escapeSelector(c)}`).join('')
      if (testSelectorUniqueness(selector, element)) {
        return selector
      }
    }
  }

  return null
}

function tryWithParentContext(element: Element, maxLevels: number = 3): string | null {
  const parents = getParentPath(element, maxLevels)

  for (const parent of parents) {
    const parentClasses = getCleanClasses(parent)
    if (parentClasses.length === 0) continue

    const elementClasses = getCleanClasses(element)
    if (elementClasses.length === 0) continue

    const parentSelector = `.${escapeSelector(parentClasses[0])}`
    const elementSelector = `.${escapeSelector(elementClasses[0])}`
    const combined = `${parentSelector} ${elementSelector}`

    if (testSelectorUniqueness(combined, element)) {
      return combined
    }
  }

  return null
}

function generateNthChildSelector(element: Element): string {
  const parent = element.parentElement
  if (!parent) {
    return element.tagName.toLowerCase()
  }

  const siblings = Array.from(parent.children)
  const index = siblings.indexOf(element)
  const parentSelector = parent.tagName.toLowerCase()

  return `${parentSelector} > ${element.tagName.toLowerCase()}:nth-child(${index + 1})`
}

function getCombinations<T>(arr: T[], size: number): T[][] {
  if (size === 1) return arr.map(item => [item])
  if (size > arr.length) return []

  const result: T[][] = []

  for (let i = 0; i <= arr.length - size; i++) {
    const head = arr[i]
    const tailCombos = getCombinations(arr.slice(i + 1), size - 1)
    tailCombos.forEach(combo => result.push([head, ...combo]))
  }

  return result
}

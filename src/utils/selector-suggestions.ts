import { generateRobustSelector } from './selector-generator'

export interface SelectorSuggestion {
  selector: string
  type: 'id' | 'data-attr' | 'semantic' | 'contextual' | 'positional'
  specificity: 'high' | 'medium' | 'low'
  description: string
  matchCount: number
}

export function generateSelectorSuggestions(element: Element): SelectorSuggestion[] {
  const suggestions: SelectorSuggestion[] = []

  // 1. ID selector (if available and not auto-generated)
  if (element.id && !/^[a-z]{1,3}-[a-f0-9]{6,}$/i.test(element.id)) {
    const selector = `#${element.id}`
    suggestions.push({
      selector,
      type: 'id',
      specificity: 'high',
      description: 'ID selector (most specific)',
      matchCount: document.querySelectorAll(selector).length
    })
  }

  // 2. Data attribute selector
  const dataAttrs = Array.from(element.attributes)
    .filter(attr => attr.name.startsWith('data-') && !attr.name.includes('reactid'))
  
  if (dataAttrs.length > 0) {
    // Try data-testid first
    const testId = dataAttrs.find(attr => attr.name === 'data-testid' || attr.name === 'data-test')
    if (testId) {
      const selector = `[${testId.name}="${testId.value}"]`
      suggestions.push({
        selector,
        type: 'data-attr',
        specificity: 'high',
        description: 'Test ID selector (recommended for testing)',
        matchCount: document.querySelectorAll(selector).length
      })
    }
    
    // Other data attributes
    const otherDataAttr = dataAttrs.find(attr => attr !== testId)
    if (otherDataAttr) {
      const selector = `[${otherDataAttr.name}="${otherDataAttr.value}"]`
      suggestions.push({
        selector,
        type: 'data-attr',
        specificity: 'medium',
        description: `Data attribute: ${otherDataAttr.name}`,
        matchCount: document.querySelectorAll(selector).length
      })
    }
  }

  // 3. Semantic class-based selector
  const semanticSelector = generateRobustSelector(element, {
    preferDataAttributes: false,
    includeParentContext: false,
    avoidAutoGenerated: true
  })
  
  if (semanticSelector && !suggestions.some(s => s.selector === semanticSelector)) {
    const matchCount = document.querySelectorAll(semanticSelector).length
    suggestions.push({
      selector: semanticSelector,
      type: 'semantic',
      specificity: matchCount === 1 ? 'medium' : 'low',
      description: 'Semantic classes',
      matchCount
    })
  }

  // 4. Contextual selector (with parent)
  const contextualSelector = generateRobustSelector(element, {
    preferDataAttributes: true,
    includeParentContext: true,
    maxParentLevels: 2,
    avoidAutoGenerated: true
  })
  
  if (contextualSelector && !suggestions.some(s => s.selector === contextualSelector)) {
    const matchCount = document.querySelectorAll(contextualSelector).length
    suggestions.push({
      selector: contextualSelector,
      type: 'contextual',
      specificity: 'medium',
      description: 'With parent context',
      matchCount
    })
  }

  // 5. More specific contextual selector if needed
  if (suggestions.every(s => s.matchCount > 1)) {
    const specificSelector = generateRobustSelector(element, {
      preferDataAttributes: true,
      includeParentContext: true,
      maxParentLevels: 3,
      avoidAutoGenerated: true
    })
    
    if (specificSelector && !suggestions.some(s => s.selector === specificSelector)) {
      const matchCount = document.querySelectorAll(specificSelector).length
      suggestions.push({
        selector: specificSelector,
        type: 'contextual',
        specificity: 'high',
        description: 'More specific context',
        matchCount
      })
    }
  }

  // 6. Text content for buttons/links
  const tagName = element.tagName.toLowerCase()
  if (['button', 'a'].includes(tagName)) {
    const text = element.textContent?.trim()
    if (text && text.length < 30) {
      // Create XPath selector for text content
      const xpathSelector = `${tagName}[contains(text(), "${text}")]`
      suggestions.push({
        selector: xpathSelector,
        type: 'contextual',
        specificity: 'medium',
        description: `By text content: "${text}"`,
        matchCount: -1 // Can't easily count XPath matches
      })
    }
  }

  // 7. Positional selector as last resort
  const positionalSelector = buildSimplePositionalSelector(element)
  if (positionalSelector && !suggestions.some(s => s.selector === positionalSelector)) {
    suggestions.push({
      selector: positionalSelector,
      type: 'positional',
      specificity: 'low',
      description: 'Position-based (may break if structure changes)',
      matchCount: document.querySelectorAll(positionalSelector).length
    })
  }

  // Sort suggestions by quality
  return suggestions.sort((a, b) => {
    // Prefer unique matches
    if (a.matchCount === 1 && b.matchCount !== 1) return -1
    if (b.matchCount === 1 && a.matchCount !== 1) return 1
    
    // Prefer higher specificity
    const specificityOrder = { high: 3, medium: 2, low: 1 }
    const specDiff = specificityOrder[a.specificity] - specificityOrder[b.specificity]
    if (specDiff !== 0) return -specDiff
    
    // Prefer certain types
    const typeOrder = { 'data-attr': 5, 'id': 4, 'semantic': 3, 'contextual': 2, 'positional': 1 }
    return typeOrder[b.type] - typeOrder[a.type]
  })
}

function buildSimplePositionalSelector(element: Element): string {
  const parts: string[] = []
  let current: Element | null = element

  while (current && current !== document.body && parts.length < 3) {
    const tagName = current.tagName.toLowerCase()
    
    if (current.parentElement) {
      const siblings = Array.from(current.parentElement.children)
        .filter(child => child.tagName === current!.tagName)
      
      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1
        parts.unshift(`${tagName}:nth-of-type(${index})`)
      } else {
        parts.unshift(tagName)
      }
    } else {
      parts.unshift(tagName)
    }

    current = current.parentElement
  }

  return parts.join(' > ')
}

export function evaluateSelector(selector: string): {
  isValid: boolean
  matchCount: number
  hasAutoGenerated: boolean
  hasTemporary: boolean
  quality: 'excellent' | 'good' | 'fair' | 'poor'
} {
  try {
    const matches = document.querySelectorAll(selector)
    const matchCount = matches.length
    
    // Check for auto-generated classes
    const hasAutoGenerated = /framer-[a-zA-Z0-9]+|css-[a-z0-9]+|sc-[a-zA-Z0-9]+/.test(selector)
    
    // Check for temporary classes
    const hasTemporary = /\.(hover|active|focus|selected|loading|is-hovered|is-active)/.test(selector)
    
    // Determine quality
    let quality: 'excellent' | 'good' | 'fair' | 'poor' = 'good'
    
    if (matchCount === 1 && !hasAutoGenerated && !hasTemporary) {
      quality = 'excellent'
    } else if (matchCount === 1) {
      quality = 'good'
    } else if (matchCount > 1 && matchCount <= 5) {
      quality = 'fair'
    } else {
      quality = 'poor'
    }
    
    return {
      isValid: true,
      matchCount,
      hasAutoGenerated,
      hasTemporary,
      quality
    }
  } catch (e) {
    return {
      isValid: false,
      matchCount: 0,
      hasAutoGenerated: false,
      hasTemporary: false,
      quality: 'poor'
    }
  }
}
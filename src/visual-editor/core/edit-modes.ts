/**
 * Edit Modes for Visual Editor
 * Handles rearrange mode (drag & drop) and resize mode functionality
 */

import StateManager from './state-manager'
import { generateRobustSelector } from '../utils/selector-generator'
import type { DOMChange } from '../types/visual-editor'

export class EditModes {
  private stateManager: StateManager
  private addChange: ((change: DOMChange) => void) | null = null

  constructor(stateManager: StateManager) {
    this.stateManager = stateManager
  }

  setAddChangeCallback(callback: (change: DOMChange) => void): void {
    this.addChange = callback
  }

  enableRearrangeMode(element: Element): void {
    console.log('[ABSmartly] Enabling rearrange mode for element:', element)

    const smartElement = this.getSmartDraggableElement(element)
    if (!smartElement) return

    this.stateManager.setRearranging(true)
    smartElement.classList.add('absmartly-draggable')

    // Check if this element already has a move change to preserve its TRUE original position
    const elementSelector = generateRobustSelector(smartElement, {
      preferDataAttributes: false,
      avoidAutoGenerated: true,
      includeParentContext: true,
      maxParentLevels: 3
    })

    const existingChanges = this.stateManager.getState().changes || []
    const existingMoveChange = existingChanges.find(
      c => c.selector === elementSelector && c.type === 'move'
    )

    // Store original parent info - use existing if available
    let originalParent: Element | null
    let originalNextSibling: Element | null

    if (existingMoveChange && (existingMoveChange as any).value?.originalTargetSelector) {
      // This element was already moved, preserve its TRUE original position
      console.log('[ABSmartly] Element already has move change, preserving original position')
      originalParent = null // Will be handled by trackMoveChange
      originalNextSibling = null // Will be handled by trackMoveChange
    } else {
      // First time moving this element, capture current position as original
      originalParent = smartElement.parentElement
      originalNextSibling = smartElement.nextElementSibling
      console.log('[ABSmartly] First move of element, capturing original position')
    }

    // Make element draggable
    ;(smartElement as HTMLElement).draggable = true

    const handleDragStart = (e: DragEvent) => {
      console.log('[ABSmartly] Drag start')
      this.stateManager.setDraggedElement(smartElement)
      smartElement.classList.add('absmartly-dragging')

      // Set drag data
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = 'move'
        e.dataTransfer.setData('text/html', smartElement.outerHTML)
      }
    }

    const handleDragOver = (e: DragEvent) => {
      e.preventDefault()
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'move'
      }
      const target = e.target as Element
      if (target !== smartElement && !smartElement.contains(target)) {
        target.classList.add('absmartly-drop-target')
      }
    }

    const handleDragLeave = (e: DragEvent) => {
      ;(e.target as Element).classList.remove('absmartly-drop-target')
    }

    const handleDrop = (e: DragEvent) => {
      e.preventDefault()
      const target = e.target as Element
      const dropTarget = target.closest('*:not(script):not(style):not(link)') as Element

      if (dropTarget && dropTarget !== smartElement && !smartElement.contains(dropTarget)) {
        // Remove drop target styling
        document.querySelectorAll('.absmartly-drop-target').forEach(el => {
          el.classList.remove('absmartly-drop-target')
        })

        // Determine drop position
        const rect = dropTarget.getBoundingClientRect()
        const dropY = e.clientY
        const insertAfter = dropY > rect.top + rect.height / 2

        try {
          if (insertAfter && dropTarget.nextElementSibling) {
            dropTarget.parentElement?.insertBefore(smartElement, dropTarget.nextElementSibling)
          } else if (!insertAfter) {
            dropTarget.parentElement?.insertBefore(smartElement, dropTarget)
          } else {
            dropTarget.parentElement?.appendChild(smartElement)
          }

          // Track the change
          this.trackMoveChange(smartElement, originalParent, originalNextSibling)
          console.log('[ABSmartly] Element moved successfully')
        } catch (error) {
          console.warn('[ABSmartly] Move failed:', error)
        }
      }
    }

    const handleDragEnd = (e: DragEvent) => {
      console.log('[ABSmartly] Drag end')

      // Clean up drag state
      smartElement.classList.remove('absmartly-dragging')
      ;(smartElement as HTMLElement).draggable = false
      this.stateManager.setDraggedElement(null)
      this.stateManager.setRearranging(false)

      // Remove all drop target indicators
      document.querySelectorAll('.absmartly-drop-target').forEach(el => {
        el.classList.remove('absmartly-drop-target')
      })

      // Remove event listeners
      smartElement.removeEventListener('dragstart', handleDragStart)
      document.removeEventListener('dragover', handleDragOver)
      document.removeEventListener('dragleave', handleDragLeave)
      document.removeEventListener('drop', handleDrop)
      smartElement.removeEventListener('dragend', handleDragEnd)

      smartElement.classList.remove('absmartly-draggable')
    }

    // Add event listeners
    smartElement.addEventListener('dragstart', handleDragStart)
    document.addEventListener('dragover', handleDragOver)
    document.addEventListener('dragleave', handleDragLeave)
    document.addEventListener('drop', handleDrop)
    smartElement.addEventListener('dragend', handleDragEnd)

    // Auto-exit after 10 seconds
    setTimeout(() => {
      if (this.stateManager.getState().isRearranging) {
        handleDragEnd(new DragEvent('dragend'))
      }
    }, 10000)
  }

  enableResizeMode(element: Element): void {
    console.log('[ABSmartly] Enabling resize mode for element:', element)
    const htmlElement = element as HTMLElement

    // Debug: Check current styles
    console.log('[ABSmartly] Current element styles:', {
      width: htmlElement.style.width,
      height: htmlElement.style.height,
      computedWidth: window.getComputedStyle(htmlElement).width,
      computedHeight: window.getComputedStyle(htmlElement).height
    })

    this.stateManager.setResizing(true)
    element.classList.add('absmartly-resize-active')

    // Set global flag to prevent DOM changes from being reapplied during resize
    ;(window as any).__absmartlyVisualEditorModifying = true
    console.log('[ABSmartly] Set visual editor modifying flag to prevent DOM changes reapplication')

    // Store original styles locally for tracking
    const originalStyles = {
      width: htmlElement.style.width,
      height: htmlElement.style.height,
      position: htmlElement.style.position,
      top: htmlElement.style.top,
      left: htmlElement.style.left
    }

    // Also store original styles in DOM for undo/redo
    if (!htmlElement.dataset.absmartlyOriginal) {
      htmlElement.dataset.absmartlyOriginal = JSON.stringify({})
    }

    const existingData = JSON.parse(htmlElement.dataset.absmartlyOriginal)
    if (!existingData.styles) {
      // Store current styles before any resize happens
      const computedStyle = window.getComputedStyle(htmlElement)
      existingData.styles = {
        width: htmlElement.style.width || computedStyle.width || '',
        height: htmlElement.style.height || computedStyle.height || ''
      }
      htmlElement.dataset.absmartlyOriginal = JSON.stringify(existingData)
      console.log('[ABSmartly] Stored original dimensions in DOM:', existingData.styles)
    }

    // Create resize handles
    const handles = this.createResizeHandles(element as HTMLElement)

    const handleMouseDown = (e: MouseEvent, direction: string) => {
      console.log('[ABSmartly] Resize handle mousedown:', direction)
      e.preventDefault()
      e.stopPropagation()

      // Set global flag to prevent DOM changes from being reapplied during resize
      ;(window as any).__absmartlyVisualEditorModifying = true
      console.log('[ABSmartly] MOUSEDOWN: Set visual editor modifying flag to prevent DOM changes reapplication', {
        flagValue: (window as any).__absmartlyVisualEditorModifying,
        timestamp: Date.now(),
        direction
      })

      const startX = e.clientX
      const startY = e.clientY
      const startRect = element.getBoundingClientRect()
      console.log('[ABSmartly] Start rect:', startRect)

      const handleMouseMove = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.clientX - startX
        const deltaY = moveEvent.clientY - startY

        this.applyResize(element as HTMLElement, direction, deltaX, deltaY, startRect)
      }

      const handleMouseUp = () => {
        document.removeEventListener('mousemove', handleMouseMove)
        document.removeEventListener('mouseup', handleMouseUp)

        // Clear global flag to allow DOM changes to be reapplied again
        ;(window as any).__absmartlyVisualEditorModifying = false
        console.log('[ABSmartly] MOUSEUP: Cleared visual editor modifying flag, DOM changes can be reapplied', {
          flagValue: (window as any).__absmartlyVisualEditorModifying,
          timestamp: Date.now()
        })

        // Track the change
        this.trackResizeChange(element, originalStyles)
      }

      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
    }

    // Attach handlers to resize handles
    handles.forEach(handle => {
      const direction = handle.dataset.direction!
      console.log('[ABSmartly] Attaching mousedown handler to handle:', direction)
      handle.addEventListener('mousedown', (e) => {
        console.log('[ABSmartly] Handle clicked:', direction)
        handleMouseDown(e, direction)
      })
    })
    console.log('[ABSmartly] Created', handles.length, 'resize handles')

    // Exit resize mode on Escape or click outside
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        this.exitResizeMode(element as HTMLElement, handles)
      }
    }

    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as Element
      if (!element.contains(target) && !target.closest('[data-absmartly-resize-handle]')) {
        this.exitResizeMode(element as HTMLElement, handles)
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('click', handleClickOutside, true)

    // Store cleanup functions
    ;(element as any).__absmartlyResizeCleanup = () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('click', handleClickOutside, true)
    }
  }

  private getSmartDraggableElement(element: Element): Element | null {
    // Logic to find the best draggable parent element
    let current: Element | null = element

    while (current && current !== document.body) {
      const tagName = current.tagName.toLowerCase()
      const computedStyle = window.getComputedStyle(current)

      // Skip inline elements unless they have specific styling
      if (computedStyle.display === 'inline' &&
          !['a', 'button', 'span'].includes(tagName)) {
        current = current.parentElement
        continue
      }

      // Prefer block-level containers
      if (['div', 'section', 'article', 'header', 'footer', 'main', 'aside'].includes(tagName)) {
        return current
      }

      // Also good candidates
      if (['li', 'tr', 'td', 'th', 'figure', 'blockquote'].includes(tagName)) {
        return current
      }

      current = current.parentElement
    }

    return element // Fallback to original element
  }

  private createResizeHandles(element: HTMLElement): HTMLElement[] {
    const handles: HTMLElement[] = []
    const directions = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w']

    directions.forEach(direction => {
      const handle = document.createElement('div')
      handle.dataset.absmartlyResizeHandle = 'true'
      handle.dataset.direction = direction
      handle.style.cssText = `
        position: absolute;
        background: #3b82f6;
        border: 2px solid white;
        border-radius: 50%;
        width: 10px;
        height: 10px;
        cursor: ${this.getResizeCursor(direction)};
        z-index: 2147483647;
        pointer-events: auto;
      `

      this.positionResizeHandle(handle, direction, element)
      handles.push(handle)
      document.body.appendChild(handle)
    })

    return handles
  }

  private positionResizeHandle(handle: HTMLElement, direction: string, element: HTMLElement): void {
    const rect = element.getBoundingClientRect()
    const scrollX = window.scrollX
    const scrollY = window.scrollY

    const positions: { [key: string]: { left: number; top: number } } = {
      'nw': { left: rect.left - 5, top: rect.top - 5 },
      'n': { left: rect.left + rect.width / 2 - 5, top: rect.top - 5 },
      'ne': { left: rect.right - 5, top: rect.top - 5 },
      'e': { left: rect.right - 5, top: rect.top + rect.height / 2 - 5 },
      'se': { left: rect.right - 5, top: rect.bottom - 5 },
      's': { left: rect.left + rect.width / 2 - 5, top: rect.bottom - 5 },
      'sw': { left: rect.left - 5, top: rect.bottom - 5 },
      'w': { left: rect.left - 5, top: rect.top + rect.height / 2 - 5 }
    }

    const pos = positions[direction]
    handle.style.left = (pos.left + scrollX) + 'px'
    handle.style.top = (pos.top + scrollY) + 'px'
    handle.style.position = 'absolute'
  }

  private getResizeCursor(direction: string): string {
    const cursors: { [key: string]: string } = {
      'nw': 'nw-resize',
      'n': 'n-resize',
      'ne': 'ne-resize',
      'e': 'e-resize',
      'se': 'se-resize',
      's': 's-resize',
      'sw': 'sw-resize',
      'w': 'w-resize'
    }
    return cursors[direction] || 'move'
  }

  private applyResize(element: HTMLElement, direction: string, deltaX: number, deltaY: number, startRect: DOMRect): void {
    console.log('[ABSmartly] RESIZE: Applying resize', {
      direction,
      deltaX,
      deltaY,
      flagValue: (window as any).__absmartlyVisualEditorModifying,
      timestamp: Date.now(),
      currentStyles: {
        width: element.style.width,
        height: element.style.height
      }
    });
    const style = element.style

    switch (direction) {
      case 'se': // Southeast - resize both width and height
        style.width = Math.max(50, startRect.width + deltaX) + 'px'
        style.height = Math.max(20, startRect.height + deltaY) + 'px'
        break

      case 'e': // East - resize width only
        style.width = Math.max(50, startRect.width + deltaX) + 'px'
        break

      case 's': // South - resize height only
        style.height = Math.max(20, startRect.height + deltaY) + 'px'
        break

      case 'sw': // Southwest
        style.width = Math.max(50, startRect.width - deltaX) + 'px'
        style.height = Math.max(20, startRect.height + deltaY) + 'px'
        break

      case 'w': // West
        style.width = Math.max(50, startRect.width - deltaX) + 'px'
        break

      case 'nw': // Northwest
        style.width = Math.max(50, startRect.width - deltaX) + 'px'
        style.height = Math.max(20, startRect.height - deltaY) + 'px'
        break

      case 'n': // North
        style.height = Math.max(20, startRect.height - deltaY) + 'px'
        break

      case 'ne': // Northeast
        style.width = Math.max(50, startRect.width + deltaX) + 'px'
        style.height = Math.max(20, startRect.height - deltaY) + 'px'
        break
    }
  }

  private exitResizeMode(element: HTMLElement, handles: HTMLElement[]): void {
    element.classList.remove('absmartly-resize-active')
    this.stateManager.setResizing(false)

    // Clear global flag to allow DOM changes to be reapplied again
    ;(window as any).__absmartlyVisualEditorModifying = false
    console.log('[ABSmartly] Cleared visual editor modifying flag, DOM changes can be reapplied')

    // Remove handles
    handles.forEach(handle => handle.remove())

    // Clean up event listeners
    if ((element as any).__absmartlyResizeCleanup) {
      ;(element as any).__absmartlyResizeCleanup()
      delete (element as any).__absmartlyResizeCleanup
    }
  }

  private trackMoveChange(element: Element, originalParent: Element | null, originalNextSibling: Element | null): void {
    console.log('[ABSmartly] Tracking move change for element:', element)

    if (!this.addChange) {
      console.warn('[ABSmartly] No addChange callback set for EditModes')
      return
    }

    // Generate robust selector for the moved element
    const elementSelector = generateRobustSelector(element, {
      preferDataAttributes: false,
      avoidAutoGenerated: true,
      includeParentContext: true,
      maxParentLevels: 3
    })

    // Check if this element already has a move change to preserve its TRUE original position
    const existingChanges = this.stateManager.getState().changes || []
    const existingMoveChange = existingChanges.find(
      c => c.selector === elementSelector && c.type === 'move'
    )

    // Determine the ORIGINAL position for reverting
    let originalTargetSelector: string | null = null
    let originalPosition: 'before' | 'after' | 'firstChild' | 'lastChild' | null = null

    if (existingMoveChange && (existingMoveChange as any).value?.originalTargetSelector) {
      // Preserve the TRUE original position from the first move
      console.log('[ABSmartly] Preserving original position from existing move change')
      originalTargetSelector = (existingMoveChange as any).value.originalTargetSelector
      originalPosition = (existingMoveChange as any).value.originalPosition
    } else if (originalNextSibling) {
      // Element was originally before its next sibling
      originalTargetSelector = generateRobustSelector(originalNextSibling, {
        preferDataAttributes: false,
        avoidAutoGenerated: true,
        includeParentContext: true,
        maxParentLevels: 3
      })
      originalPosition = 'before'
    } else if (originalParent) {
      // Element was the last child of its parent
      const previousSibling = Array.from(originalParent.children).find(
        child => child.nextElementSibling === null && child !== element
      )
      if (previousSibling) {
        originalTargetSelector = generateRobustSelector(previousSibling, {
          preferDataAttributes: false,
          avoidAutoGenerated: true,
          includeParentContext: true,
          maxParentLevels: 3
        })
        originalPosition = 'after'
      } else {
        // Was the only or first child
        originalTargetSelector = generateRobustSelector(originalParent, {
          preferDataAttributes: false,
          avoidAutoGenerated: true,
          includeParentContext: true,
          maxParentLevels: 3
        })
        originalPosition = originalParent.firstElementChild === element ? 'firstChild' : 'lastChild'
      }
    }

    // Determine the CURRENT target and position for the move
    const currentParent = element.parentElement
    const currentNextSibling = element.nextElementSibling

    let targetSelector: string
    let position: 'before' | 'after' | 'firstChild' | 'lastChild'

    if (currentNextSibling) {
      // Element was placed before its next sibling
      targetSelector = generateRobustSelector(currentNextSibling, {
        preferDataAttributes: false,
        avoidAutoGenerated: true,
        includeParentContext: true,
        maxParentLevels: 3
      })
      position = 'before'
    } else if (element.previousElementSibling) {
      // Element was placed after its previous sibling
      targetSelector = generateRobustSelector(element.previousElementSibling, {
        preferDataAttributes: false,
        avoidAutoGenerated: true,
        includeParentContext: true,
        maxParentLevels: 3
      })
      position = 'after'
    } else if (currentParent) {
      // Element is the only child or first child
      targetSelector = generateRobustSelector(currentParent, {
        preferDataAttributes: false,
        avoidAutoGenerated: true,
        includeParentContext: true,
        maxParentLevels: 3
      })
      position = currentParent.firstElementChild === element ? 'firstChild' : 'lastChild'
    } else {
      console.warn('[ABSmartly] Could not determine move target')
      return
    }

    // Create the move change
    const moveChange: DOMChange = {
      selector: elementSelector,
      type: 'move',
      targetSelector,
      position
    }

    console.log('[ABSmartly] Creating move change with original position:', moveChange)
    this.addChange(moveChange)
  }

  private trackResizeChange(element: Element, originalStyles: any): void {
    console.log('[ABSmartly] Tracking resize change for element:', element)

    if (!this.addChange) {
      console.warn('[ABSmartly] No addChange callback set for EditModes')
      return
    }

    const htmlElement = element as HTMLElement
    const currentStyles = {
      width: htmlElement.style.width,
      height: htmlElement.style.height
    }

    // Only track if styles actually changed
    if (currentStyles.width !== originalStyles.width || currentStyles.height !== originalStyles.height) {
      const elementSelector = generateRobustSelector(element, {
        preferDataAttributes: false,
        avoidAutoGenerated: true,
        includeParentContext: true,
        maxParentLevels: 3
      })

      const styleChange: DOMChange = {
        selector: elementSelector,
        type: 'style',
        value: currentStyles
      }

      console.log('[ABSmartly] Creating resize/style change:', styleChange)
      this.addChange(styleChange)
    }
  }
}

export default EditModes
/**
 * Event Handlers for Visual Editor
 * Handles mouse events, clicks, and interaction logic
 */

import { generateRobustSelector } from '../utils/selector-generator'
import StateManager from './state-manager'

export class EventHandlers {
  private stateManager: StateManager
  private isEditing = false
  private hoverTooltip: HTMLElement | null = null

  constructor(stateManager: StateManager) {
    this.stateManager = stateManager
  }

  handleMouseOver = (e: MouseEvent): void => {
    // Ignore preview header elements
    if ((e.target as Element).closest('#absmartly-preview-header')) {
      return
    }
    if (this.isEditing) return
    const target = e.target as Element

    // Don't hover on our Shadow DOM hosts
    if (target.id === 'absmartly-visual-editor-banner-host' ||
        target.closest('#absmartly-visual-editor-banner-host') ||
        target.id === 'absmartly-menu-host' ||
        target.closest('#absmartly-menu-host') ||
        target.id === 'absmartly-html-editor-host' ||
        target.closest('#absmartly-html-editor-host') ||
        target.id === 'absmartly-hover-tooltip') {
      return
    }

    target.classList.add('absmartly-hover')
    this.stateManager.setHoveredElement(target)

    // Show tooltip with element selector
    if (this.hoverTooltip) {
      this.hoverTooltip.remove()
    }

    const selector = generateRobustSelector(target, {
      preferDataAttributes: false,
      avoidAutoGenerated: true,
      includeParentContext: true,
      maxParentLevels: 3
    })

    this.hoverTooltip = document.createElement('div')
    this.hoverTooltip.id = 'absmartly-hover-tooltip'
    this.hoverTooltip.style.cssText = `
      position: fixed;
      background: #1f2937;
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      z-index: 2147483647;
      pointer-events: none;
      white-space: nowrap;
      max-width: 400px;
      overflow: hidden;
      text-overflow: ellipsis;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `
    this.hoverTooltip.textContent = selector

    // Position tooltip near cursor
    const rect = target.getBoundingClientRect()
    const tooltipX = Math.min(rect.left, window.innerWidth - 420)
    const tooltipY = rect.top - 30

    this.hoverTooltip.style.left = tooltipX + 'px'
    this.hoverTooltip.style.top = (tooltipY < 10 ? rect.bottom + 5 : tooltipY) + 'px'

    document.body.appendChild(this.hoverTooltip)
  }

  handleMouseOut = (e: MouseEvent): void => {
    if (this.isEditing) return
    ;(e.target as Element).classList.remove('absmartly-hover')
    this.stateManager.setHoveredElement(null)

    // Remove tooltip
    if (this.hoverTooltip) {
      this.hoverTooltip.remove()
      this.hoverTooltip = null
    }
  }

  handleClick = (e: MouseEvent): void => {
    const target = e.target as Element
    const config = this.stateManager.getConfig()

    // CRITICAL: Check for menu host first (shadow DOM container)
    const menuHost = document.getElementById('absmartly-menu-host')
    if (menuHost && (menuHost === target || menuHost.contains(target))) {
      // Don't interfere with shadow DOM menu at all
      return
    }

    // Don't open menu if clicking within editable content
    if (this.isEditing || (target as HTMLElement).contentEditable === 'true') {
      return
    }

    // Ignore clicks on our UI (banner, editor hosts, toolbar, and preview header)
    if (target.id === 'absmartly-visual-editor-banner-host' ||
        target.closest('#absmartly-visual-editor-banner-host') ||
        target.id === 'absmartly-html-editor-host' ||
        target.closest('#absmartly-html-editor-host') ||
        target.closest('.absmartly-toolbar') ||
        target.id === 'absmartly-preview-header' ||
        target.closest('#absmartly-preview-header')) {
      return
    }

    // IMPORTANT: Don't show menu if we're currently editing text
    if (this.isEditing || (target as HTMLElement).contentEditable === 'true') {
      console.log('[ABSmartly] Ignoring click - currently editing')
      return
    }

    // Now prevent default for page elements
    e.preventDefault()
    e.stopPropagation()

    // Remove previous selection and menu
    const currentSelected = this.stateManager.getState().selectedElement
    if (currentSelected) {
      currentSelected.classList.remove('absmartly-selected')
    }
    const existingHost = document.getElementById('absmartly-menu-host')
    if (existingHost) existingHost.remove()

    // Select new element
    this.stateManager.setSelectedElement(target)
    target.classList.remove('absmartly-hover')
    target.classList.add('absmartly-selected')

    // Store original values in DOM immediately when element is selected
    // This ensures we always have the original value before any changes
    if (!(target as HTMLElement).dataset.absmartlyOriginal) {
      (target as HTMLElement).dataset.absmartlyOriginal = JSON.stringify({
        textContent: target.textContent,
        innerHTML: target.innerHTML
      })
      ;(target as HTMLElement).dataset.absmartlyExperiment = config.experimentName || '__preview__'
    }

    // Show context menu - this will be handled by context-menu module
    console.log('[EventHandlers] Calling showContextMenu at', e.pageX, e.pageY, 'for element:', target)
    this.showContextMenu(e.pageX, e.pageY, target)
  }

  setEditing(editing: boolean): void {
    this.isEditing = editing
  }

  get isEditingMode(): boolean {
    return this.isEditing
  }

  // This will be set by the main visual editor to connect to context menu
  showContextMenu: (x: number, y: number, element: Element) => void = (x, y, element) => {
    console.log('[ABSmartly] Context menu requested at', x, y, 'for element', element)
  }

  attachEventListeners(): void {
    document.addEventListener('mouseover', this.handleMouseOver, true)
    document.addEventListener('mouseout', this.handleMouseOut, true)
    document.addEventListener('click', this.handleClick, true)
  }

  detachEventListeners(): void {
    document.removeEventListener('mouseover', this.handleMouseOver, true)
    document.removeEventListener('mouseout', this.handleMouseOut, true)
    document.removeEventListener('click', this.handleClick, true)

    // Clean up tooltip
    if (this.hoverTooltip) {
      this.hoverTooltip.remove()
      this.hoverTooltip = null
    }
  }
}

export default EventHandlers
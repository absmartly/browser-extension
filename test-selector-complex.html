<!DOCTYPE html>
<html>
<head>
  <title>Complex Selector Test - Using Actual Function</title>
</head>
<body>
  <!-- Complex nested structure with duplicate IDs -->
  <div id="main-container">
    <!-- First carousel -->
    <div id="carousel-wrapper">
      <div class="carousel-inner">
        <ul>
          <li>
            <div id="card-content">
              <span data-testid="item-1">Item 1 in first carousel</span>
            </div>
          </li>
          <li>
            <div id="card-content">
              <span data-testid="item-2">Item 2 in first carousel</span>
            </div>
          </li>
        </ul>
      </div>
    </div>

    <!-- Second carousel with same structure -->
    <div id="carousel-wrapper">
      <div class="carousel-inner">
        <ul>
          <li>
            <div id="card-content">
              <span>Item 1 in second carousel</span>
            </div>
          </li>
          <li>
            <div id="card-content">
              <span>Item 2 in second carousel</span>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Amazon-like structure -->
  <div id="bhp-ab-gateway-desktop-atf-6">
    <div>
      <div>
        <div>
          <div>
            <ul>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Product 1</span>
                    </div>
                  </a>
                </div>
              </li>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Product 2</span>
                    </div>
                  </a>
                </div>
              </li>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Product 3</span>
                    </div>
                  </a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Auto-generated IDs test -->
  <div id="css-1a2b3c4">
    <div id="framer-xyz123">
      <div id="123auto">
        <span class="MuiBox-root-456">Auto-generated test</span>
      </div>
    </div>
  </div>

  <!-- Single elements (should not have nth-child) -->
  <div id="unique-parent">
    <span>Only span here</span>
  </div>

  <div id="another-unique">
    <div>
      <p>Only paragraph here</p>
    </div>
  </div>

  <script>
    // COPY THE ACTUAL getSelector FUNCTION FROM background.ts
    function getSelector(element) {
      if (!element) return ''

      // Try to find the minimal unique selector
      // First check if element itself has a unique ID
      if (element.id && !isAutoGenerated(element.id)) {
        const idMatches = document.querySelectorAll('#' + element.id)
        if (idMatches.length === 1) {
          console.log('[ABSmartly] Element has unique ID:', element.id)
          return '#' + element.id
        }
      }

      // Check for data attributes (but skip ABSmartly-added ones)
      const dataAttrs = Array.from(element.attributes)
        .filter(attr => {
          return attr.name.startsWith('data-') &&
                 !attr.name.startsWith('data-absmartly') &&
                 attr.value &&
                 attr.value.length < 50 &&
                 !attr.value.includes('"') &&
                 !attr.value.includes("'")
        })

      // Prefer certain data attributes that are commonly used for testing
      const preferredDataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-id', 'data-name']
      const preferredAttr = dataAttrs.find(attr => preferredDataAttrs.includes(attr.name))

      if (preferredAttr) {
        const dataSelector = '[' + preferredAttr.name + '="' + preferredAttr.value + '"]'
        try {
          const matches = document.querySelectorAll(dataSelector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Using data attribute selector:', dataSelector)
            return dataSelector
          }
        } catch (e) {
          console.error('[ABSmartly] Invalid data selector:', e)
        }
      }

      // Build selector using parent chain if no good ID or class
      // First, collect the element path from target to root
      let pathElements = []
      let current = element
      const maxDepth = 10

      while (current && current !== document.body && current !== document.documentElement && pathElements.length < maxDepth) {
        pathElements.push(current)
        current = current.parentElement
      }

      // Look for the closest element with an ID (even if duplicate) and build minimal path
      for (let i = 0; i < pathElements.length; i++) {
        const elem = pathElements[i]

        if (elem.id && !isAutoGenerated(elem.id)) {
          // Found an ID, try to build selector from here
          let selector = '#' + elem.id

          // Add minimal path from this ID to target
          if (i > 0) {
            // Check if we need intermediate elements
            let minimalPath = []

            // First try direct child selector
            if (i === 1) {
              // Direct child
              minimalPath = [pathElements[0].tagName.toLowerCase()]
            } else {
              // Try with just the target element tag
              minimalPath = [pathElements[0].tagName.toLowerCase()]
              let testSel = selector + ' ' + minimalPath.join(' > ')
              let testMatches = document.querySelectorAll(testSel)

              if (testMatches.length !== 1 || testMatches[0] !== element) {
                // Need more specificity, add immediate parent
                minimalPath = []
                for (let j = i - 1; j >= 0; j--) {
                  const pathElem = pathElements[j]
                  if (pathElem.id && !isAutoGenerated(pathElem.id)) {
                    minimalPath.push('#' + pathElem.id)
                    break
                  } else {
                    minimalPath.push(pathElem.tagName.toLowerCase())
                  }
                }
              }
            }

            selector = selector + ' > ' + minimalPath.join(' > ')
          }

          // Test if this selector is unique
          const matches = document.querySelectorAll(selector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Found minimal selector with ID:', selector)
            return selector
          }

          // If not unique, we need parent context
          // Find the minimal parent that makes it unique
          for (let parentIdx = i + 1; parentIdx < pathElements.length; parentIdx++) {
            const parent = pathElements[parentIdx]
            let parentSelector = ''

            if (parent.id && !isAutoGenerated(parent.id)) {
              parentSelector = '#' + parent.id
            } else {
              // Build path from this parent
              continue
            }

            const fullSelector = parentSelector + ' ' + selector
            const fullMatches = document.querySelectorAll(fullSelector)

            if (fullMatches.length === 1 && fullMatches[0] === element) {
              console.log('[ABSmartly] Made unique with parent context:', fullSelector)
              return fullSelector
            }
          }
        }
      }

      // Try with minimal tag path, but always include parent IDs for context
      for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
        let basePath = []
        let foundId = false

        for (let i = startDepth - 1; i >= 0; i--) {
          const elem = pathElements[i]

          // If we find a parent with ID, use it as anchor
          if (elem.id && !isAutoGenerated(elem.id)) {
            basePath.unshift('#' + elem.id)
            foundId = true
            // Add remaining path to target
            for (let j = i - 1; j >= 0; j--) {
              basePath.push(pathElements[j].tagName.toLowerCase())
            }
            break
          } else {
            basePath.unshift(elem.tagName.toLowerCase())
          }
        }

        const selector = basePath.join(' > ')
        const matches = document.querySelectorAll(selector)

        if (matches.length === 1 && matches[0] === element) {
          // Don't accept single tag selectors - too brittle!
          if (!selector.includes('#') && !selector.includes('>') && !selector.includes('[')) {
            console.log('[ABSmartly] Single tag selector too brittle, continuing search:', selector)
            continue
          }
          console.log('[ABSmartly] Found unique selector with context:', selector)
          return selector
        }
      }

      // If simple tag paths don't work, we need to add specificity
      console.log('[ABSmartly] Simple paths not unique. Adding specificity...')

      // Try using duplicate IDs with parent context to make them unique
      for (let i = 0; i < pathElements.length; i++) {
        const elem = pathElements[i]

        if (elem.id && !isAutoGenerated(elem.id)) {
          // Even if ID is duplicate, try to use it with parent context
          let baseSelector = '#' + elem.id

          // Add minimal path to target if needed
          if (i > 0) {
            // Check if child has ID too
            const child = pathElements[0]
            if (child.id && !isAutoGenerated(child.id)) {
              baseSelector = baseSelector + ' #' + child.id
            } else {
              // Just add the child tag
              baseSelector = baseSelector + ' > ' + child.tagName.toLowerCase()
            }
          }

          // Test if unique
          let matches = document.querySelectorAll(baseSelector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Found unique selector using duplicate ID:', baseSelector)
            return baseSelector
          }

          // Try with parent IDs
          for (let p = i + 1; p < pathElements.length; p++) {
            const parent = pathElements[p]
            if (parent.id && !isAutoGenerated(parent.id)) {
              const parentSelector = '#' + parent.id + ' ' + baseSelector
              matches = document.querySelectorAll(parentSelector)
              if (matches.length === 1 && matches[0] === element) {
                console.log('[ABSmartly] Made unique with parent ID:', parentSelector)
                return parentSelector
              }
            }
          }
        }
      }

      // Try adding nth-child only where necessary
      for (let targetIndex = 0; targetIndex < pathElements.length; targetIndex++) {
        const targetElem = pathElements[targetIndex]

        // Try minimal selector with nth-child at this level
        // Start from different depths to find the minimal one
        for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
          let specificPath = []
          let foundUniqueId = false

          for (let i = startDepth - 1; i >= 0; i--) {
            const elem = pathElements[i]

            if (elem.id && !isAutoGenerated(elem.id)) {
              const idMatches = document.querySelectorAll('#' + elem.id)
              if (idMatches.length === 1) {
                // Unique ID found, use as anchor
                specificPath = ['#' + elem.id]
                foundUniqueId = true
                // Add rest of path
                for (let j = i - 1; j >= 0; j--) {
                  if (j === targetIndex && pathElements[j].parentElement) {
                    // Only add nth-child at target if needed
                    const siblings = Array.from(pathElements[j].parentElement.children)
                    if (siblings.length > 1) {
                      const childIndex = siblings.indexOf(pathElements[j]) + 1
                      specificPath.push(pathElements[j].tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
                    } else {
                      specificPath.push(pathElements[j].tagName.toLowerCase())
                    }
                  } else {
                    specificPath.push(pathElements[j].tagName.toLowerCase())
                  }
                }
                break
              } else {
                // Duplicate ID - still use it!
                if (i === targetIndex && elem.parentElement) {
                  // Only add nth-child if there are multiple siblings
                  const siblings = Array.from(elem.parentElement.children)
                  if (siblings.length > 1) {
                    const childIndex = siblings.indexOf(elem) + 1
                    specificPath.unshift('#' + elem.id + ':nth-child(' + childIndex + ')')
                  } else {
                    specificPath.unshift('#' + elem.id)
                  }
                } else {
                  specificPath.unshift('#' + elem.id)
                }
              }
            } else if (i === targetIndex && elem.parentElement) {
              // Add nth-child at target level only if there are multiple siblings
              const siblings = Array.from(elem.parentElement.children)
              if (siblings.length > 1) {
                const childIndex = siblings.indexOf(elem) + 1
                specificPath.unshift(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
              } else {
                specificPath.unshift(elem.tagName.toLowerCase())
              }
            } else {
              specificPath.unshift(elem.tagName.toLowerCase())
            }
          }

          const testSelector = specificPath.join(' > ')
          const testMatches = document.querySelectorAll(testSelector)

          if (testMatches.length === 1 && testMatches[0] === element) {
            console.log('[ABSmartly] Found minimal unique selector with nth-child at', targetElem.tagName, ':', testSelector)
            return testSelector
          }

          // If we have a unique ID anchor, no need to try longer paths
          if (foundUniqueId) break
        }
      }

      // Last resort - build full path with nth-child where needed
      let selector = pathElements.map((elem, i) => {
        let sel = elem.tagName.toLowerCase()
        if (elem.parentElement && i > 0) {
          const siblings = Array.from(elem.parentElement.children)
          if (siblings.length > 1) {
            const idx = siblings.indexOf(elem) + 1
            sel += ':nth-child(' + idx + ')'
          }
        }
        return sel
      }).reverse().join(' > ')

      console.log('[ABSmartly] Final selector:', selector, 'Matches:', document.querySelectorAll(selector).length)
      return selector
    }

    // Helper function to check if string is auto-generated
    function isAutoGenerated(str) {
      if (!str) return false

      // CRITICAL: Skip IDs/classes added by ABSmartly itself
      if (str.includes('absmartly') || str.includes('ABSmartly')) {
        return true
      }

      // IDs starting with numbers are likely auto-generated
      if (/^[0-9]/.test(str)) {
        return true
      }

      // Check for framework-specific patterns
      const patterns = [
        /^framer-[a-zA-Z0-9]+$/,  // Framer classes
        /^css-[a-z0-9]+$/i,  // CSS modules
        /^sc-[a-zA-Z0-9]+$/,  // Styled-components
        /^v-[a-f0-9]{8}$/,  // Vue scoped classes
        /^svelte-[a-z0-9]+$/,  // Svelte classes
        /^emotion-[0-9]+$/,  // Emotion CSS
        /^chakra-/,  // Chakra UI
        /^MuiBox-root/,  // Material-UI
        /^[a-f0-9]{8,}$/i,  // Hex strings
        /_[a-f0-9]{6,}$/i  // Ending with hex strings
      ]

      if (patterns.some(pattern => pattern.test(str))) {
        return true
      }

      // Look for random character sequences in segments
      const segments = str.split(/[-_]/)
      for (const segment of segments) {
        if (segment.length < 6) continue

        // Check if segment looks like a normal word
        const looksNormal = /^[A-Z][a-z]+$/.test(segment) || // PascalCase word
                           /^[a-z]+$/.test(segment) ||        // all lowercase
                           /^[A-Z]+$/.test(segment) ||        // all uppercase
                           /^[a-z]+[0-9]{1,2}$/.test(segment) // word with 1-2 digits

        if (!looksNormal) {
          // Check for random patterns: mixed case/numbers without clear pattern
          if (/[0-9][a-zA-Z]{2,}[0-9]/.test(segment) ||  // number-letters-number
              /[a-z][A-Z]{2,}[a-z]/.test(segment) ||      // lowercase-UPPER-lowercase
              /[A-Z][a-z][0-9][a-zA-Z]{3,}/.test(segment)) { // Mixed pattern
            return true
          }
        }
      }

      return false
    }

    // Test function
    function runTests() {
      console.log('=== COMPLEX SELECTOR TESTS ===\n')

      const testCases = [
        {
          name: 'Duplicate IDs in carousels',
          selector: '#carousel-wrapper #card-content span'
        },
        {
          name: 'Amazon-like duplicate IDs',
          selector: '#bhp-ab-gateway-desktop-atf-6 #bnp-recs-card-title span'
        },
        {
          name: 'Elements with data-testid',
          selector: '[data-testid="item-1"]'
        },
        {
          name: 'Single span (should not have nth-child)',
          selector: '#unique-parent > span'
        },
        {
          name: 'Single paragraph (should not have nth-child)',
          selector: '#another-unique p'
        },
        {
          name: 'Auto-generated IDs (should be ignored)',
          selector: '#css-1a2b3c4 span'
        }
      ]

      testCases.forEach(test => {
        console.log(`\n--- Test: ${test.name} ---`)
        const elements = document.querySelectorAll(test.selector)
        console.log(`Found ${elements.length} elements matching "${test.selector}"`)

        elements.forEach((elem, index) => {
          const selector = getSelector(elem)
          const matches = document.querySelectorAll(selector)
          const isUnique = matches.length === 1 && matches[0] === elem

          console.log(`\nElement ${index + 1}: "${elem.textContent.trim()}"`)
          console.log(`Generated selector: ${selector}`)
          console.log(`Unique: ${isUnique ? '✅' : '❌'} (matches: ${matches.length})`)

          // Check for issues
          if (!isUnique) {
            console.error('⚠️  SELECTOR NOT UNIQUE!')
          }

          // Check for unnecessary nth-child(1)
          if (selector.includes(':nth-child(1)')) {
            const parent = elem.parentElement
            if (parent && parent.children.length === 1) {
              console.warn('⚠️  Unnecessary :nth-child(1) detected!')
            }
          }

          // Check for overly long paths
          const divCount = (selector.match(/div/g) || []).length
          if (divCount > 3) {
            console.warn(`⚠️  Many intermediate divs (${divCount}). Could be simplified?`)
          }
        })
      })

      console.log('\n\n=== SUMMARY ===')
      console.log('Expected behaviors:')
      console.log('1. ✅ Use duplicate IDs with parent context (e.g., #parent #duplicate-id)')
      console.log('2. ✅ Prefer data-testid when available')
      console.log('3. ✅ No :nth-child(1) when element is only child')
      console.log('4. ✅ Minimal paths without unnecessary intermediate elements')
      console.log('5. ✅ Ignore auto-generated IDs and classes')
    }

    // Run tests when page loads
    window.addEventListener('load', () => {
      setTimeout(runTests, 100)
    })
  </script>
</body>
</html>
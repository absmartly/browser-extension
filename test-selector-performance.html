<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Selector Performance Test</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .results { margin: 20px 0; padding: 10px; background: #f5f5f5; }
    .winner { background: #d4edda; font-weight: bold; }
  </style>
</head>
<body>
  <h1>CSS Selector Performance Comparison</h1>
  <div id="results"></div>

  <!-- Test DOM Structure -->
  <div id="test-container">
    <!-- Create many elements to test performance -->
    <div id="parent-container">
      <!-- 100 items with duplicate IDs -->
      <script>
        for (let i = 0; i < 100; i++) {
          document.write(`
            <div class="item">
              <div id="duplicate-id" data-testid="item-${i}">
                <span>Item ${i}</span>
              </div>
            </div>
          `);
        }
      </script>
    </div>

    <!-- Unique ID element -->
    <div id="unique-element">Unique</div>

    <!-- Single element with data attribute -->
    <div data-testid="single-test">Single</div>
  </div>

  <script>
    function runPerformanceTest() {
      const results = document.getElementById('results');
      const iterations = 100000; // 100k iterations for each selector

      // Test cases
      const tests = [
        {
          name: 'Unique ID (#unique-element)',
          selector: '#unique-element',
          expected: document.querySelector('#unique-element')
        },
        {
          name: 'Duplicate ID with parent context (#parent-container > .item:nth-child(50) > #duplicate-id)',
          selector: '#parent-container > .item:nth-child(50) > #duplicate-id',
          expected: document.querySelector('#parent-container > .item:nth-child(50) > #duplicate-id')
        },
        {
          name: 'Duplicate ID with simpler parent (#parent-container #duplicate-id)',
          selector: '#parent-container #duplicate-id',
          expected: document.querySelectorAll('#parent-container #duplicate-id')[0]
        },
        {
          name: 'Data attribute ([data-testid="item-49"])',
          selector: '[data-testid="item-49"]',
          expected: document.querySelector('[data-testid="item-49"]')
        },
        {
          name: 'Data attribute with parent (#parent-container [data-testid="item-49"])',
          selector: '#parent-container [data-testid="item-49"]',
          expected: document.querySelector('#parent-container [data-testid="item-49"]')
        },
        {
          name: 'Complex descendant selector (#parent-container > div > div > span)',
          selector: '#parent-container > div > div > span',
          expected: document.querySelector('#parent-container > div > div > span')
        },
        {
          name: 'Class with nth-child (.item:nth-child(50) > div)',
          selector: '.item:nth-child(50) > div',
          expected: document.querySelector('.item:nth-child(50) > div')
        }
      ];

      // Run tests
      const testResults = [];

      tests.forEach(test => {
        // Warm up
        for (let i = 0; i < 100; i++) {
          document.querySelector(test.selector);
        }

        // Actual test
        const start = performance.now();
        for (let i = 0; i < iterations; i++) {
          const elem = document.querySelector(test.selector);
        }
        const end = performance.now();
        const time = end - start;

        // Verify selector works
        const found = document.querySelector(test.selector);
        const isCorrect = found === test.expected;

        testResults.push({
          name: test.name,
          selector: test.selector,
          time: time,
          opsPerSec: Math.round(iterations / (time / 1000)),
          isCorrect: isCorrect
        });
      });

      // Sort by performance
      testResults.sort((a, b) => a.time - b.time);

      // Display results
      let html = '<h2>Results (sorted by speed, fastest first):</h2>';
      html += '<div class="results">';

      testResults.forEach((result, index) => {
        const isWinner = index === 0;
        const relativeSpeed = (result.time / testResults[0].time).toFixed(2);

        html += `
          <div class="${isWinner ? 'winner' : ''}">
            <strong>${index + 1}. ${result.name}</strong><br>
            Selector: <code>${result.selector}</code><br>
            Time: ${result.time.toFixed(2)}ms<br>
            Ops/sec: ${result.opsPerSec.toLocaleString()}<br>
            ${isWinner ? 'üèÜ FASTEST' : `${relativeSpeed}x slower than fastest`}<br>
            Valid: ${result.isCorrect ? '‚úÖ' : '‚ùå'}<br>
            <hr>
          </div>
        `;
      });

      html += '</div>';

      // Add analysis
      html += '<h2>Analysis:</h2>';
      html += '<div class="results">';

      // Find specific comparisons
      const uniqueId = testResults.find(r => r.selector === '#unique-element');
      const duplicateWithParent = testResults.find(r => r.selector === '#parent-container > .item:nth-child(50) > #duplicate-id');
      const dataAttr = testResults.find(r => r.selector === '[data-testid="item-49"]');
      const dataWithParent = testResults.find(r => r.selector === '#parent-container [data-testid="item-49"]');

      if (uniqueId && duplicateWithParent && dataAttr) {
        html += `
          <p><strong>Key Findings:</strong></p>
          <ul>
            <li>Unique ID is ${(duplicateWithParent.time / uniqueId.time).toFixed(1)}x faster than duplicate ID with parent context</li>
            <li>Unique ID is ${(dataAttr.time / uniqueId.time).toFixed(1)}x faster than data attribute</li>
            <li>Duplicate ID with parent is ${(dataAttr.time / duplicateWithParent.time).toFixed(1)}x ${duplicateWithParent.time < dataAttr.time ? 'faster' : 'slower'} than data attribute</li>
            <li>Data attribute with parent ID is ${(dataAttr.time / dataWithParent.time).toFixed(1)}x ${dataWithParent.time < dataAttr.time ? 'faster' : 'slower'} than plain data attribute</li>
          </ul>
        `;
      }

      html += `
        <p><strong>Performance Hierarchy (based on this test):</strong></p>
        <ol>
      `;

      // Group by selector type
      const hierarchy = [
        { type: 'Unique IDs', example: '#unique-id' },
        { type: 'IDs with parent context', example: '#parent #duplicate-id' },
        { type: 'IDs with complex path', example: '#parent > div:nth-child(n) > #id' },
        { type: 'Data attributes with parent ID', example: '#parent [data-testid="..."]' },
        { type: 'Data attributes alone', example: '[data-testid="..."]' },
        { type: 'Class selectors with nth-child', example: '.class:nth-child(n)' },
        { type: 'Complex descendant selectors', example: 'div > div > div > span' }
      ];

      hierarchy.forEach(item => {
        html += `<li>${item.type} - <code>${item.example}</code></li>`;
      });

      html += '</ol></div>';

      results.innerHTML = html;
    }

    // Run test on load
    window.addEventListener('load', () => {
      console.log('Running performance test...');
      runPerformanceTest();
    });

    // Allow re-running
    window.runTest = runPerformanceTest;
  </script>

  <button onclick="runTest()">Re-run Test</button>

  <div style="margin-top: 40px; padding: 20px; background: #f0f0f0;">
    <h3>Test Methodology:</h3>
    <ul>
      <li>100,000 iterations of querySelector for each selector type</li>
      <li>100 elements with duplicate IDs to simulate real-world scenarios</li>
      <li>Warm-up phase before each test to avoid JIT compilation bias</li>
      <li>Tests run in order, then sorted by performance</li>
    </ul>
  </div>
</body>
</html>
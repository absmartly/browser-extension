<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Selector Generation Unit Tests</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .test-container { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
    .pass { color: green; }
    .fail { color: red; }
    .warn { color: orange; }
    .result { background: #f5f5f5; padding: 5px; margin: 5px 0; }
  </style>
</head>
<body>
  <h1>Selector Generation Unit Tests</h1>
  <div id="test-output"></div>

  <!-- TEST CASES HTML -->

  <!-- Test 1: Unique IDs -->
  <div class="test-container">
    <div id="unique-header">
      <h1>Page Title</h1>
    </div>
    <div id="unique-content">
      <p>Some content</p>
    </div>
  </div>

  <!-- Test 2: Duplicate IDs (like Amazon) -->
  <div class="test-container">
    <div id="product-list">
      <div class="item">
        <div id="price-tag">$10.99</div>
        <div id="product-title">Product 1</div>
      </div>
      <div class="item">
        <div id="price-tag">$20.99</div>
        <div id="product-title">Product 2</div>
      </div>
      <div class="item">
        <div id="price-tag">$30.99</div>
        <div id="product-title">Product 3</div>
      </div>
    </div>
  </div>

  <!-- Test 3: Data attributes -->
  <div class="test-container">
    <button data-testid="submit-button">Submit</button>
    <button data-testid="cancel-button">Cancel</button>
    <input data-test="email-input" type="email" value="test@example.com">
    <input data-cy="password-field" type="password" value="hidden">
  </div>

  <!-- Test 4: Nested structures without IDs -->
  <div class="test-container">
    <article>
      <header>
        <h2>Article Title</h2>
      </header>
      <section>
        <p>First paragraph in section</p>
        <p>Second paragraph in section</p>
        <p>Third paragraph in section</p>
      </section>
      <footer>
        <span>Author name</span>
      </footer>
    </article>
  </div>

  <!-- Test 5: Lists -->
  <div class="test-container">
    <ul id="nav-menu">
      <li><a href="#">Home</a></li>
      <li><a href="#">About</a></li>
      <li><a href="#">Contact</a></li>
    </ul>
    <ul id="footer-menu">
      <li><a href="#">Privacy</a></li>
      <li><a href="#">Terms</a></li>
    </ul>
  </div>

  <!-- Test 6: Auto-generated IDs (should be ignored) -->
  <div class="test-container">
    <div id="css-1a2b3c">
      <div id="framer-xyz123">
        <div id="sc-aBcDeF123">
          <span class="MuiBox-root-456">Component with auto-generated IDs</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Test 7: Single children (should not have :nth-child(1)) -->
  <div class="test-container">
    <div id="single-child-parent">
      <div>
        <span>Only span here</span>
      </div>
    </div>
  </div>

  <!-- Test 8: Multiple children (should have :nth-child) -->
  <div class="test-container">
    <div id="multi-child-parent">
      <div>First div</div>
      <div>Second div</div>
      <div>Third div</div>
    </div>
  </div>

  <!-- Test 9: Complex e-commerce layout -->
  <div class="test-container">
    <div id="shop-container">
      <div class="row">
        <div class="col">
          <div class="card">
            <div class="card-header">
              <span class="price">$99.99</span>
            </div>
            <div class="card-body">
              <h3>Product A</h3>
            </div>
          </div>
        </div>
        <div class="col">
          <div class="card">
            <div class="card-header">
              <span class="price">$199.99</span>
            </div>
            <div class="card-body">
              <h3>Product B</h3>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Test 10: ABSmartly attributes (should be ignored) -->
  <div class="test-container">
    <div data-absmartly-experiment="test-exp" id="absmartly-preview">
      <p>This has ABSmartly attributes</p>
    </div>
  </div>

  <script>
    // ACTUAL getSelector function from background.ts
    function getSelector(element) {
      if (!element) return ''

      // Try to find the minimal unique selector
      // First check if element itself has a unique ID
      if (element.id && !isAutoGenerated(element.id)) {
        const idMatches = document.querySelectorAll('#' + element.id)
        if (idMatches.length === 1) {
          console.log('[ABSmartly] Element has unique ID:', element.id)
          return '#' + element.id
        }
      }

      // Check for data attributes (but skip ABSmartly-added ones)
      const dataAttrs = Array.from(element.attributes)
        .filter(attr => {
          return attr.name.startsWith('data-') &&
                 !attr.name.startsWith('data-absmartly') &&
                 attr.value &&
                 attr.value.length < 50 &&
                 !attr.value.includes('"') &&
                 !attr.value.includes("'")
        })

      // Prefer certain data attributes that are commonly used for testing
      const preferredDataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-id', 'data-name']
      const preferredAttr = dataAttrs.find(attr => preferredDataAttrs.includes(attr.name))

      if (preferredAttr) {
        const dataSelector = '[' + preferredAttr.name + '="' + preferredAttr.value + '"]'
        try {
          const matches = document.querySelectorAll(dataSelector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Using data attribute selector:', dataSelector)
            return dataSelector
          }
        } catch (e) {
          console.error('[ABSmartly] Invalid data selector:', e)
        }
      }

      // Build selector using parent chain
      let pathElements = []
      let current = element
      const maxDepth = 10

      while (current && current !== document.body && current !== document.documentElement && pathElements.length < maxDepth) {
        pathElements.push(current)
        current = current.parentElement
      }

      // Look for the closest element with an ID (even if duplicate) and build minimal path
      for (let i = 0; i < pathElements.length; i++) {
        const elem = pathElements[i]

        if (elem.id && !isAutoGenerated(elem.id)) {
          // Found an ID, try to build selector from here
          let selector = '#' + elem.id

          // Add minimal path from this ID to target
          if (i > 0) {
            // Check if we need intermediate elements
            let minimalPath = []

            // First try direct child selector
            if (i === 1) {
              // Direct child
              minimalPath = [pathElements[0].tagName.toLowerCase()]
            } else {
              // Try with just the target element tag
              minimalPath = [pathElements[0].tagName.toLowerCase()]
              let testSel = selector + ' ' + minimalPath.join(' > ')
              let testMatches = document.querySelectorAll(testSel)

              if (testMatches.length !== 1 || testMatches[0] !== element) {
                // Need more specificity, add immediate parent
                minimalPath = []
                for (let j = i - 1; j >= 0; j--) {
                  const pathElem = pathElements[j]
                  if (pathElem.id && !isAutoGenerated(pathElem.id)) {
                    minimalPath.push('#' + pathElem.id)
                    break
                  } else {
                    minimalPath.push(pathElem.tagName.toLowerCase())
                  }
                }
              }
            }

            selector = selector + ' > ' + minimalPath.join(' > ')
          }

          // Test if this selector is unique
          const matches = document.querySelectorAll(selector)
          if (matches.length === 1 && matches[0] === element) {
            console.log('[ABSmartly] Found minimal selector with ID:', selector)
            return selector
          }

          // If not unique, we need parent context
          // Find the minimal parent that makes it unique
          for (let parentIdx = i + 1; parentIdx < pathElements.length; parentIdx++) {
            const parent = pathElements[parentIdx]
            let parentSelector = ''

            if (parent.id && !isAutoGenerated(parent.id)) {
              parentSelector = '#' + parent.id
            } else {
              continue
            }

            const fullSelector = parentSelector + ' ' + selector
            const fullMatches = document.querySelectorAll(fullSelector)

            if (fullMatches.length === 1 && fullMatches[0] === element) {
              console.log('[ABSmartly] Made unique with parent context:', fullSelector)
              return fullSelector
            }
          }
        }
      }

      // Try with minimal tag path, but always include parent IDs for context
      for (let startDepth = 1; startDepth <= pathElements.length; startDepth++) {
        let basePath = []
        let foundId = false

        for (let i = startDepth - 1; i >= 0; i--) {
          const elem = pathElements[i]

          // If we find a parent with ID, use it as anchor
          if (elem.id && !isAutoGenerated(elem.id)) {
            basePath.unshift('#' + elem.id)
            foundId = true
            // Add remaining path to target
            for (let j = i - 1; j >= 0; j--) {
              basePath.push(pathElements[j].tagName.toLowerCase())
            }
            break
          } else {
            basePath.unshift(elem.tagName.toLowerCase())
          }
        }

        const selector = basePath.join(' > ')
        const matches = document.querySelectorAll(selector)

        if (matches.length === 1 && matches[0] === element) {
          // Don't accept single tag selectors - too brittle!
          if (!selector.includes('#') && !selector.includes('>') && !selector.includes('[')) {
            console.log('[ABSmartly] Single tag selector too brittle, continuing search:', selector)
            continue
          }
          console.log('[ABSmartly] Found unique selector with context:', selector)
          return selector
        }
      }

      // If simple paths don't work, add specificity with nth-child
      // (Rest of the logic for nth-child handling...)

      // Fallback to full path with nth-child
      let selector = pathElements.map((elem, i) => {
        let sel = elem.tagName.toLowerCase()
        if (elem.parentElement && i > 0) {
          const siblings = Array.from(elem.parentElement.children)
          if (siblings.length > 1) {
            const idx = siblings.indexOf(elem) + 1
            sel += ':nth-child(' + idx + ')'
          }
        }
        return sel
      }).reverse().join(' > ')

      return selector
    }

    // Helper function to check if string is auto-generated
    function isAutoGenerated(str) {
      if (!str) return false

      // CRITICAL: Skip IDs/classes added by ABSmartly itself
      if (str.includes('absmartly') || str.includes('ABSmartly')) {
        return true
      }

      // IDs starting with numbers are likely auto-generated
      if (/^[0-9]/.test(str)) {
        return true
      }

      // Check for framework-specific patterns
      const patterns = [
        /^framer-[a-zA-Z0-9]+$/,
        /^css-[a-z0-9]+$/i,
        /^sc-[a-zA-Z0-9]+$/,
        /^v-[a-f0-9]{8}$/,
        /^svelte-[a-z0-9]+$/,
        /^emotion-[0-9]+$/,
        /^chakra-/,
        /^MuiBox-root/,
        /^[a-f0-9]{8,}$/i,
        /_[a-f0-9]{6,}$/i
      ]

      if (patterns.some(pattern => pattern.test(str))) {
        return true
      }

      // Look for random character sequences
      const segments = str.split(/[-_]/)
      for (const segment of segments) {
        if (segment.length < 6) continue

        const looksNormal = /^[A-Z][a-z]+$/.test(segment) ||
                           /^[a-z]+$/.test(segment) ||
                           /^[A-Z]+$/.test(segment) ||
                           /^[a-z]+[0-9]{1,2}$/.test(segment)

        if (!looksNormal) {
          if (/[0-9][a-zA-Z]{2,}[0-9]/.test(segment) ||
              /[a-z][A-Z]{2,}[a-z]/.test(segment) ||
              /[A-Z][a-z][0-9][a-zA-Z]{3,}/.test(segment)) {
            return true
          }
        }
      }

      return false
    }

    // Unit test runner
    function runUnitTests() {
      const output = document.getElementById('test-output')
      output.innerHTML = ''

      const tests = [
        {
          name: 'Unique IDs',
          cases: [
            { selector: '#unique-header > h1', desc: 'H1 with unique parent ID' },
            { selector: '#unique-content > p', desc: 'Paragraph with unique parent ID' }
          ]
        },
        {
          name: 'Duplicate IDs (should use parent context)',
          cases: [
            { selector: '#product-list .item:nth-child(1) #price-tag', desc: 'First price tag' },
            { selector: '#product-list .item:nth-child(2) #price-tag', desc: 'Second price tag' },
            { selector: '#product-list .item:nth-child(1) #product-title', desc: 'First product title' },
            { selector: '#product-list .item:nth-child(3) #product-title', desc: 'Third product title' }
          ]
        },
        {
          name: 'Data attributes (preferred for testing)',
          cases: [
            { selector: '[data-testid="submit-button"]', desc: 'Button with data-testid' },
            { selector: '[data-testid="cancel-button"]', desc: 'Button with data-testid' },
            { selector: '[data-test="email-input"]', desc: 'Input with data-test' },
            { selector: '[data-cy="password-field"]', desc: 'Input with data-cy' }
          ]
        },
        {
          name: 'Nested structures without IDs',
          cases: [
            { selector: 'article > header > h2', desc: 'H2 in article header' },
            { selector: 'article > section > p:nth-child(1)', desc: 'First paragraph in section' },
            { selector: 'article > section > p:nth-child(2)', desc: 'Second paragraph in section' },
            { selector: 'article > footer > span', desc: 'Span in article footer' }
          ]
        },
        {
          name: 'List items',
          cases: [
            { selector: '#nav-menu > li:nth-child(1) > a', desc: 'First nav menu link' },
            { selector: '#nav-menu > li:nth-child(3) > a', desc: 'Third nav menu link' },
            { selector: '#footer-menu > li:nth-child(2) > a', desc: 'Second footer menu link' }
          ]
        },
        {
          name: 'Auto-generated IDs (should be ignored)',
          cases: [
            { selector: '.test-container span.MuiBox-root-456', desc: 'Span with auto-generated class' }
          ]
        },
        {
          name: 'Single children (no unnecessary :nth-child)',
          cases: [
            { selector: '#single-child-parent > div > span', desc: 'Single span (no :nth-child(1))' }
          ]
        },
        {
          name: 'Multiple children (needs :nth-child)',
          cases: [
            { selector: '#multi-child-parent > div:nth-child(1)', desc: 'First child div' },
            { selector: '#multi-child-parent > div:nth-child(2)', desc: 'Second child div' },
            { selector: '#multi-child-parent > div:nth-child(3)', desc: 'Third child div' }
          ]
        },
        {
          name: 'E-commerce cards',
          cases: [
            { selector: '#shop-container .col:nth-child(1) .price', desc: 'First product price' },
            { selector: '#shop-container .col:nth-child(2) h3', desc: 'Second product title' }
          ]
        },
        {
          name: 'ABSmartly attributes (should be ignored)',
          cases: [
            { selector: '.test-container p', desc: 'Paragraph inside ABSmartly container' }
          ]
        }
      ]

      let totalTests = 0
      let passedTests = 0
      let failedTests = 0

      tests.forEach(testGroup => {
        const groupDiv = document.createElement('div')
        groupDiv.className = 'test-group'
        groupDiv.innerHTML = `<h2>${testGroup.name}</h2>`

        testGroup.cases.forEach(testCase => {
          totalTests++
          const element = document.querySelector(testCase.selector)

          if (!element) {
            failedTests++
            groupDiv.innerHTML += `
              <div class="result fail">
                ❌ ${testCase.desc}
                <br>Element not found: ${testCase.selector}
              </div>`
            return
          }

          const generated = getSelector(element)
          const matches = document.querySelectorAll(generated)
          const isUnique = matches.length === 1 && matches[0] === element

          // Check quality of selector
          const issues = []

          // Check if selector is unique
          if (!isUnique) {
            issues.push('Not unique (matches ' + matches.length + ' elements)')
          }

          // Check for brittle single-tag selectors
          if (generated.match(/^[a-z]+$/)) {
            issues.push('Too brittle (single tag)')
          }

          // Check for unnecessary :nth-child(1)
          if (generated.includes(':nth-child(1)')) {
            const parent = element.parentElement
            if (parent && parent.children.length === 1) {
              issues.push('Unnecessary :nth-child(1)')
            }
          }

          // Check for too many intermediate divs
          const divCount = (generated.match(/\bdiv\b/g) || []).length
          if (divCount > 4) {
            issues.push(`Too many divs (${divCount})`)
          }

          const status = issues.length === 0 ? 'pass' : 'fail'
          if (status === 'pass') passedTests++
          else failedTests++

          groupDiv.innerHTML += `
            <div class="result ${status}">
              ${status === 'pass' ? '✅' : '❌'} ${testCase.desc}
              <br><strong>Expected:</strong> ${testCase.selector}
              <br><strong>Generated:</strong> ${generated}
              ${issues.length > 0 ? '<br><span class="warn">Issues: ' + issues.join(', ') + '</span>' : ''}
            </div>`
        })

        output.appendChild(groupDiv)
      })

      // Summary
      const summary = document.createElement('div')
      summary.innerHTML = `
        <h2>Test Summary</h2>
        <div class="result">
          Total: ${totalTests} |
          <span class="pass">Passed: ${passedTests}</span> |
          <span class="fail">Failed: ${failedTests}</span>
        </div>
        <div class="result">
          Success Rate: ${Math.round(passedTests / totalTests * 100)}%
        </div>
      `
      output.appendChild(summary)

      // Print all selectors to console for verification
      console.log('\n=== ALL GENERATED SELECTORS ===\n')
      tests.forEach(testGroup => {
        console.log(`\n${testGroup.name}:`)
        console.log('-'.repeat(50))
        testGroup.cases.forEach(testCase => {
          const element = document.querySelector(testCase.selector)
          if (element) {
            const generated = getSelector(element)
            console.log(`${testCase.desc}:`)
            console.log(`  Expected: ${testCase.selector}`)
            console.log(`  Generated: ${generated}`)
          }
        })
      })
    }

    // Run tests on load
    window.addEventListener('load', () => {
      // Clear console for clean output
      console.clear()
      setTimeout(runUnitTests, 100)
    })
  </script>
</body>
</html>
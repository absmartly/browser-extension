<!DOCTYPE html>
<html>
<head>
  <title>Selector Test</title>
</head>
<body>
  <div id="bhp-ab-gateway-desktop-atf-6">
    <div>
      <div>
        <div>
          <div>
            <ul>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>First item text</span>
                    </div>
                  </a>
                </div>
              </li>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Second item text</span>
                    </div>
                  </a>
                </div>
              </li>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Third item text</span>
                    </div>
                  </a>
                </div>
              </li>
              <li>
                <div>
                  <a id="bnp-link">
                    <div id="bnp-recs-card-title">
                      <span>Fourth item text</span>
                    </div>
                  </a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Test the selector generation logic with duplicate ID detection
    function isAutoGenerated(str) {
      if (!str) return false

      // IDs starting with numbers are likely auto-generated
      if (/^[0-9]/.test(str)) {
        return true
      }

      // Check for framework-specific patterns
      const patterns = [
        /^framer-[a-zA-Z0-9]+$/,  // Framer classes
        /^css-[a-z0-9]+$/i,  // CSS modules
        /^sc-[a-zA-Z0-9]+$/,  // Styled-components
        /^v-[a-f0-9]{8}$/,  // Vue scoped classes
        /^svelte-[a-z0-9]+$/,  // Svelte classes
        /^emotion-[0-9]+$/,  // Emotion CSS
        /^chakra-/,  // Chakra UI
        /^MuiBox-root/,  // Material-UI
        /^[a-f0-9]{8,}$/i,  // Hex strings
        /_[a-f0-9]{6,}$/i  // Ending with hex strings
      ]

      if (patterns.some(pattern => pattern.test(str))) {
        return true
      }

      // Look for random character sequences in segments
      const segments = str.split(/[-_]/)
      for (const segment of segments) {
        if (segment.length < 6) continue

        // Check if segment looks like a normal word
        const looksNormal = /^[A-Z][a-z]+$/.test(segment) || // PascalCase word
                           /^[a-z]+$/.test(segment) ||        // all lowercase
                           /^[A-Z]+$/.test(segment) ||        // all uppercase
                           /^[a-z]+[0-9]{1,2}$/.test(segment) // word with 1-2 digits

        if (!looksNormal) {
          // Check for random patterns: mixed case/numbers without clear pattern
          if (/[0-9][a-zA-Z]{2,}[0-9]/.test(segment) ||  // number-letters-number
              /[a-z][A-Z]{2,}[a-z]/.test(segment) ||      // lowercase-UPPER-lowercase
              /[A-Z][a-z][0-9][a-zA-Z]{3,}/.test(segment)) { // Mixed pattern
            return true
          }
        }
      }

      return false
    }

    function getSelector(element) {
      if (!element) return ''

      // Build selector using parent chain if no good ID or class
      // First, collect the element path from target to root
      let pathElements = []
      let current = element
      const maxDepth = 10

      while (current && current !== document.body && current !== document.documentElement && pathElements.length < maxDepth) {
        pathElements.push(current)
        current = current.parentElement
      }

      // Build a minimal selector first (just tags, skipping duplicate IDs)
      let basePath = []
      for (let i = pathElements.length - 1; i >= 0; i--) {
        const elem = pathElements[i]

        if (elem.id && !isAutoGenerated(elem.id)) {
          // Check if this ID is actually unique in the document
          const idMatches = document.querySelectorAll('#' + elem.id)
          if (idMatches.length === 1) {
            // ID is unique, safe to use as anchor
            basePath = ['#' + elem.id]
          } else {
            // ID is duplicated, treat as regular element
            console.log('[ABSmartly] Ignoring duplicate ID:', elem.id, 'found', idMatches.length, 'times')
            basePath.push(elem.tagName.toLowerCase())
          }
        } else {
          basePath.push(elem.tagName.toLowerCase())
        }
      }

      // Test if minimal selector is unique
      let selector = basePath.join(' > ')
      let matches = document.querySelectorAll(selector)

      if (matches.length === 1 && matches[0] === element) {
        console.log('[ABSmartly] Simple selector is unique:', selector)
        return selector
      }

      // Not unique - we need to add specificity
      if (matches.length > 1) {
        console.log('[ABSmartly] Simple selector matches', matches.length, 'elements. Adding specificity...')

        // Find the highest ancestor where adding nth-child makes it unique
        // Start from the element itself and work up
        for (let targetIndex = 0; targetIndex < pathElements.length; targetIndex++) {
          const targetElem = pathElements[targetIndex]

          // Skip if this element has a unique ID (we already use it)
          if (targetElem.id && !isAutoGenerated(targetElem.id)) {
            const idMatches = document.querySelectorAll('#' + targetElem.id)
            if (idMatches.length === 1) {
              continue
            }
          }

          // Build selector with nth-child at this specific level
          let specificPath = []

          for (let i = pathElements.length - 1; i >= 0; i--) {
            const elem = pathElements[i]

            if (elem.id && !isAutoGenerated(elem.id)) {
              // Check if ID is unique before using it
              const idMatches = document.querySelectorAll('#' + elem.id)
              if (idMatches.length === 1) {
                // Start fresh from this unique ID
                specificPath = ['#' + elem.id]
              } else {
                // ID is duplicate, add as regular tag with nth-child if at target level
                if (i === targetIndex && elem.parentElement) {
                  const childIndex = Array.from(elem.parentElement.children).indexOf(elem) + 1
                  specificPath.push(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
                } else {
                  specificPath.push(elem.tagName.toLowerCase())
                }
              }
            } else if (i === targetIndex && elem.parentElement) {
              // Add nth-child at this specific level
              const childIndex = Array.from(elem.parentElement.children).indexOf(elem) + 1
              specificPath.push(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
            } else {
              // Just tag name
              specificPath.push(elem.tagName.toLowerCase())
            }
          }

          const testSelector = specificPath.join(' > ')
          const testMatches = document.querySelectorAll(testSelector)

          if (testMatches.length === 1 && testMatches[0] === element) {
            console.log('[ABSmartly] Made unique by adding nth-child to', targetElem.tagName, 'at index', targetIndex, ':', testSelector)
            return testSelector
          }
        }

        // If still not unique, try adding nth-of-type where there are siblings
        let pathWithTypes = []

        for (let i = pathElements.length - 1; i >= 0; i--) {
          const elem = pathElements[i]

          if (elem.id && !isAutoGenerated(elem.id)) {
            // Check if ID is unique before using it
            const idMatches = document.querySelectorAll('#' + elem.id)
            if (idMatches.length === 1) {
              pathWithTypes = ['#' + elem.id]
            } else {
              // ID is duplicate, treat as regular element
              let sel = elem.tagName.toLowerCase()
              if (elem.parentElement) {
                const siblings = Array.from(elem.parentElement.children)
                  .filter(child => child.tagName === elem.tagName)
                if (siblings.length > 1) {
                  const index = siblings.indexOf(elem) + 1
                  sel += ':nth-of-type(' + index + ')'
                }
              }
              pathWithTypes.push(sel)
            }
          } else {
            let sel = elem.tagName.toLowerCase()

            // Add nth-of-type if there are siblings of the same type
            if (elem.parentElement) {
              const siblings = Array.from(elem.parentElement.children)
                .filter(child => child.tagName === elem.tagName)

              if (siblings.length > 1) {
                const index = siblings.indexOf(elem) + 1
                sel += ':nth-of-type(' + index + ')'
              }
            }

            pathWithTypes.push(sel)
          }
        }

        selector = pathWithTypes.join(' > ')
        matches = document.querySelectorAll(selector)

        if (matches.length === 1 && matches[0] === element) {
          console.log('[ABSmartly] Made unique with nth-of-type:', selector)
          return selector
        }

        // Last resort: use nth-child on everything
        console.log('[ABSmartly] Using fallback with nth-child on all elements')
        let fallbackPath = []

        for (let i = pathElements.length - 1; i >= 0; i--) {
          const elem = pathElements[i]

          if (elem.id && !isAutoGenerated(elem.id)) {
            // Check if ID is unique before using it
            const idMatches = document.querySelectorAll('#' + elem.id)
            if (idMatches.length === 1) {
              fallbackPath = ['#' + elem.id]
            } else if (elem.parentElement) {
              // ID is duplicate, use nth-child
              const childIndex = Array.from(elem.parentElement.children).indexOf(elem) + 1
              fallbackPath.push(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
            } else {
              fallbackPath.push(elem.tagName.toLowerCase())
            }
          } else if (elem.parentElement) {
            const childIndex = Array.from(elem.parentElement.children).indexOf(elem) + 1
            fallbackPath.push(elem.tagName.toLowerCase() + ':nth-child(' + childIndex + ')')
          } else {
            fallbackPath.push(elem.tagName.toLowerCase())
          }
        }

        selector = fallbackPath.join(' > ')
      }

      console.log('[ABSmartly] Final selector:', selector, 'Matches:', document.querySelectorAll(selector).length)
      return selector
    }

    // Test function
    function testSelectors() {
      console.log('=== Testing Selector Generation with Duplicate IDs ===')

      // Get all span elements
      const spans = document.querySelectorAll('li span')
      console.log('Found', spans.length, 'span elements in li items')

      spans.forEach((span, index) => {
        console.log('\n--- Testing span', index + 1, ':', span.textContent)
        const selector = getSelector(span)

        // Verify the selector
        const matches = document.querySelectorAll(selector)
        const isUnique = matches.length === 1 && matches[0] === span

        console.log('Generated selector:', selector)
        console.log('Matches found:', matches.length)
        console.log('Is unique?', isUnique ? '✅ YES' : '❌ NO')

        if (!isUnique) {
          console.error('ERROR: Selector is not unique!')
        }
      })

      console.log('\n=== Test Complete ===')
    }

    // Run test when page loads
    window.addEventListener('load', testSelectors)
  </script>
</body>
</html>